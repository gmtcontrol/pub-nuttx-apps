/*
 * Copyright (C) 2014 BlueKitchen GmbH
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 * 4. Any redistribution, use, or modification is done solely for
 *    personal benefit and not for any commercial purpose or for
 *    monetary gain.
 *
 * THIS SOFTWARE IS PROVIDED BY BLUEKITCHEN GMBH AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BLUEKITCHEN
 * GMBH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Please inquire about commercial licensing options at
 * contact@bluekitchen-gmbh.com
 *
 */

#define BTSTACK_FILE__ "ublox_spp_le_mapkit.c"

// *****************************************************************************
/* EXAMPLE_START(ublox_spp_le_mapkit): LE u-blox SPP-like GNSS Server
 *
 */
 // *****************************************************************************

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <poll.h>

#include <uORB/uORB.h>

#include "btstack.h"
#include "ble/gatt-service/device_information_service_server.h"
#include "ble/gatt-service/ublox_spp_service_server.h"

// ublox_spp_le_mapkit.gatt contains the declaration of the provided GATT Services + Characteristics
// ublox_spp_le_mapkit.h    contains the binary representation of ublox_spp_le_mapkit.gatt
// it is generated by the build system by calling: $BTSTACK_ROOT/tool/compile_gatt.py ublox_spp_le_mapkit.gatt ublox_spp_le_mapkit.h
// it needs to be regenerated when the GATT Database declared in ublox_spp_le_mapkit.gatt file is modified
#include "ublox_spp_le_mapkit.h"

#define POLL_PERIOD_MS  (10)
#define POLL_DELAY_SEC  (1)
#define NPOLLFDS        (1)

/****************************************************************************
 * Private Data
 ****************************************************************************/

/* @section Main Application Setup
 *
 * @text Listing MainConfiguration shows main application code.
 * It initializes L2CAP, the Security Manager and configures the ATT Server with the pre-compiled
 * ATT Database generated from $ublox_spp_le_mapkit.gatt$.
 * Additionally, it enables the Battery Service Server with the current battery level.
 * Finally, it configures the advertisements
 * and the poll_timer handler and boots the Bluetooth stack.
 * In this example, the Advertisement contains the Flags attribute and the device name.
 * The flag 0x06 indicates: LE General Discoverable Mode and BR/EDR not supported.
 */

/* LISTING_START(MainConfiguration): Init L2CAP SM ATT Server and start poll_timer timer */

struct mapkit_data_s
{
  btstack_packet_callback_registration_t  hci_event;
  btstack_context_callback_registration_t send_req;
  btstack_timer_source_t poll_timer;
  hci_con_handle_t con_handle;
  uint8_t *send_buf;
  uint16_t send_len;
  struct pollfd *fds;
  struct orb_object uorb;
};

static struct mapkit_data_s g_mapkit_data;

const uint8_t adv_data[] =
{
  // Flags general discoverable, BR/EDR not supported
  2, BLUETOOTH_DATA_TYPE_FLAGS, 0x06,
  // Name
  5, BLUETOOTH_DATA_TYPE_COMPLETE_LOCAL_NAME, '6', '-','5', '6',
  // UUID ...
  17, BLUETOOTH_DATA_TYPE_COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS, 0x1, 0xd7, 0xe9, 0x1, 0x4f, 0xf3, 0x44, 0xe7, 0x83, 0x8f, 0xe2, 0x26, 0xb9, 0xe1, 0x56, 0x24,
};
const uint8_t adv_data_len = sizeof(adv_data);


/****************************************************************************
 * Name: sensor_subscribe
 ****************************************************************************/

static struct pollfd *sensor_subscribe(struct mapkit_data_s *priv,
                                       FAR const char *topic_name,
                                       float topic_rate,
                                       int topic_latency)
{
  FAR struct pollfd *fds;
  size_t len;
  int fd;

  /* Allocate poll data */

  fds = malloc(sizeof(struct pollfd));
  if (!fds)
    {
      return NULL;
    }

  /* calculate the inverval */

  float interval = topic_rate ? (1000000 / topic_rate) : 0;

  /* get the object meta */

  len = strlen(topic_name) - 1;
  priv->uorb.instance = topic_name[len] - '0';
  priv->uorb.meta     = orb_get_meta(topic_name);

  /* subscribe to the topic */

  fd = orb_subscribe_multi(priv->uorb.meta, priv->uorb.instance);
  if (fd < 0)
    {
      free(fds);
      return NULL;
    }

  /* set the interval */

  if (interval != 0)
    {
      orb_set_interval(fd, (unsigned)interval);

      if (topic_latency != 0)
        {
          orb_set_batch_interval(fd, topic_latency);
        }
    }

  fds->fd = fd;
  fds->events = POLLIN;

  return fds;
}

/****************************************************************************
 * Name: ublox_can_send
 ****************************************************************************/

static void ublox_can_send(void *context)
{
  struct mapkit_data_s *priv = (struct mapkit_data_s *)context;

  if (priv->send_len)
    {
      /* Send the saved data to the client */

      ublox_spp_service_server_send(priv->con_handle, priv->send_buf, priv->send_len);

      /* Clear the data lenght */

      priv->send_len = 0;
    }
}

/****************************************************************************
 * Name: uorb_ondata
 *
 * Description:
 *   Print topic data by its print_message callback.
 *
 * Input Parameters:
 *   meta         The uORB metadata.
 *   fd           Subscriber handle.
 *
 * Returned Value:
 *   0 on success copy, otherwise -1
 ****************************************************************************/

static int uorb_ondata(struct mapkit_data_s *priv,
                       FAR const struct orb_metadata *meta,
                       int fd)
{
  char buffer[meta->o_size];
  FAR struct sensor_gnss_raw *gnss = (FAR struct sensor_gnss_raw *)buffer;
  int ret;

  ret = orb_copy(meta, fd, buffer);
  if (priv && ret == OK)
    {
      /* Check the connection validity */

      if ((priv->con_handle != HCI_CON_HANDLE_INVALID) && !priv->send_len)
      {
        /* Prepare to send the received data to the client */

        memcpy(priv->send_buf, gnss->buf,
               priv->send_len = gnss->len);

        /* Trigger the send function */

        priv->send_req.context  = (void*)priv;
        priv->send_req.callback = &ublox_can_send;
        ublox_spp_service_server_request_can_send_now(&priv->send_req,
                                                       priv->con_handle);
      }

      /* Skip the read data */

      orb_ioctl(fd, SNIOC_SKIP_BUFFER,
                (unsigned long)(uintptr_t)&meta->o_size);
    }

  return ret;
}

/****************************************************************************
 * Name: sensor_poll
 ****************************************************************************/

static void sensor_poll(struct mapkit_data_s *priv)
{
  /* Check the uORB topic event */

  if (priv && priv->fds != NULL)
    {
      while (poll(priv->fds, NPOLLFDS, POLL_DELAY_SEC) == NPOLLFDS)
        {
          if (priv->fds->revents & POLLIN)
            {
              if (uorb_ondata(priv, priv->uorb.meta, priv->fds->fd) < 0)
                {
                  break;
                }
            }
        }
    }
}

/****************************************************************************
 * Name: sensor_timer_handler
 ****************************************************************************/

static void sensor_timer_handler(struct btstack_timer_source *ts)
{
  struct mapkit_data_s *priv = (struct mapkit_data_s *)ts->context;

  /* Poll the sensor */

  if (priv->con_handle != HCI_CON_HANDLE_INVALID)
    {
      sensor_poll(priv);
    }

  /* Restart the timer */

  btstack_run_loop_set_timer(ts, POLL_PERIOD_MS);
  btstack_run_loop_add_timer(ts);
}

/****************************************************************************
 * Name: sensor_timer_setup
 ****************************************************************************/

static void sensor_timer_setup(void *context)
{
  struct mapkit_data_s *priv = (struct mapkit_data_s *)context;

  /* set one-shot timer */

  priv->poll_timer.process = &sensor_timer_handler;
  priv->poll_timer.context = context;
  btstack_run_loop_set_timer(&priv->poll_timer, POLL_PERIOD_MS);
  btstack_run_loop_add_timer(&priv->poll_timer);
}

/****************************************************************************
 * Name: ublox_spp_packet_handler
 ****************************************************************************/

static void ublox_spp_packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size)
{
  UNUSED(channel);
  switch (packet_type)
  {
    case HCI_EVENT_PACKET:
      if (hci_event_packet_get_type(packet) != HCI_EVENT_GATTSERVICE_META)
      {
        break;
      }

      switch (hci_event_gattservice_meta_get_subevent_code(packet))
      {
        case GATTSERVICE_SUBEVENT_SPP_SERVICE_CONNECTED:
          g_mapkit_data.con_handle = gattservice_subevent_spp_service_connected_get_con_handle(packet);
          printf("Connected with handle 0x%04x\n", g_mapkit_data.con_handle);
          break;

        case GATTSERVICE_SUBEVENT_SPP_SERVICE_DISCONNECTED:
          printf("Disconnected with handle 0x%04x\n", g_mapkit_data.con_handle);
          g_mapkit_data.con_handle = HCI_CON_HANDLE_INVALID;
          break;

        default:
          break;
      }
      break;

    case RFCOMM_DATA_PACKET:
      printf("RECV: ");
#ifdef ENABLE_PRINTF_HEXDUMP
      printf_hexdump(packet, size);
#else
      packet[size] = 0;
      printf((char*)packet);
#endif /* ENABLE_PRINTF_HEXDUMP */
      break;

    default:
      break;
  }
}

/*
 * @section Packet Handler
 *
 * @text The packet handler is used to:
 *        - stop the counter after a disconnect
 */

static void packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size)
{
  UNUSED(channel);
  UNUSED(size);

  switch (packet_type)
  {
    case HCI_EVENT_PACKET:
      switch (hci_event_packet_get_type(packet))
      {
        case HCI_EVENT_DISCONNECTION_COMPLETE:
          g_mapkit_data.con_handle = HCI_CON_HANDLE_INVALID;
          break;

        default:
          break;
      }
      break;

    default:
      break;
  }
}

/****************************************************************************
 * Name: btstack_app
 ****************************************************************************/

int btstack_app(int argc, FAR char *argv[])
{
  (void)argc;
  (void)argv;

  /* Initialize the mapkit data */

  memset(&g_mapkit_data, 0, sizeof(g_mapkit_data));

  /* Clear the connection handle */

  g_mapkit_data.con_handle = HCI_CON_HANDLE_INVALID;

  /* Allocate the GNSS raw data buffer */

  g_mapkit_data.send_len = 0;
  g_mapkit_data.send_buf = malloc(SENSOR_GNSS_RAWDATA_SIZE);
  if (!g_mapkit_data.send_buf)
    {
      return EXIT_FAILURE;
    }

  /* Register the event topic(s) */

  g_mapkit_data.fds = sensor_subscribe(&g_mapkit_data,
                                       "sensor_gnss_raw0",
                                       1000/POLL_PERIOD_MS, 0);
  if (!g_mapkit_data.fds)
    {
      free(g_mapkit_data.send_buf);
      return EXIT_FAILURE;
    }

  /* Configure the sensor poll timer */

  sensor_timer_setup((void*)&g_mapkit_data);

  /* register for HCI events */

  g_mapkit_data.hci_event.callback = &packet_handler;
  hci_add_event_handler(&g_mapkit_data.hci_event);

  /* Initialize the BTstack */

  l2cap_init();

  /* Initialize LE Security Manager: Display only */

  sm_init();

  /* setup ATT server */

  att_server_init(profile_data, NULL, NULL);

  /* setup device information service */

  device_information_service_server_init();

  /* setup u-blox SPP service */

  ublox_spp_service_server_init(&ublox_spp_packet_handler);

  /* setup advertisements */

  uint16_t adv_int_min = 0x0030;
  uint16_t adv_int_max = 0x0030;
  uint8_t adv_type = 0;
  bd_addr_t null_addr;
  memset(null_addr, 0, 6);
  gap_advertisements_set_params(adv_int_min, adv_int_max, adv_type, 0, null_addr, 0x07, 0x00);
  gap_advertisements_set_data(adv_data_len, (uint8_t*) adv_data);
  gap_advertisements_enable(1);

  /* turn on! */

  hci_power_control(HCI_POWER_ON);

  return 0;
}
