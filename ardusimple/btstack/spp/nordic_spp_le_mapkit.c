/*
 * Copyright (C) 2014 BlueKitchen GmbH
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 * 4. Any redistribution, use, or modification is done solely for
 *    personal benefit and not for any commercial purpose or for
 *    monetary gain.
 *
 * THIS SOFTWARE IS PROVIDED BY BLUEKITCHEN GMBH AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BLUEKITCHEN
 * GMBH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Please inquire about commercial licensing options at
 * contact@bluekitchen-gmbh.com
 *
 */

#define BTSTACK_FILE__ "nordic_spp_le_mapkit.c"

// *****************************************************************************
/* EXAMPLE_START(nordic_spp_le_mapkit): LE Nordic SPP-like GNSS Server
 *
 */
 // *****************************************************************************

#include <sys/param.h>

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <poll.h>

#include <nuttx/mm/circbuf.h>
#include <uORB/uORB.h>
#include <rtcm_message.h>
#include <btstack_status.h>

#include "btstack.h"
#include "ble/gatt-service/nordic_spp_service_server.h"

// nordic_spp_le_mapkit.gatt contains the declaration of the provided GATT Services + Characteristics
// nordic_spp_le_mapkit.h    contains the binary representation of nordic_spp_le_mapkit.gatt
// it is generated by the build system by calling: $BTSTACK_ROOT/tool/compile_gatt.py nordic_spp_le_mapkit.gatt nordic_spp_le_mapkit.h
// it needs to be regenerated when the GATT Database declared in nordic_spp_le_mapkit.gatt file is modified
#include "nordic_spp_le_mapkit.h"

#define POLL_PERIOD_MS  (10)
#define POLL_DELAY_SEC  (1)
#define NPOLLFDS        (1)

#define GNSS_MSG_SIZE   (82)
#define GNSS_MSG_NUM    (20)

/****************************************************************************
 * Private Data
 ****************************************************************************/

/* @section Main Application Setup
 *
 * @text Listing MainConfiguration shows main application code.
 * It initializes L2CAP, the Security Manager and configures the ATT Server with the pre-compiled
 * ATT Database generated from $nordic_spp_le_mapkit.gatt$.
 * Additionally, it enables the Battery Service Server with the current battery level.
 * Finally, it configures the advertisements
 * and the poll_timer handler and boots the Bluetooth stack.
 * In this example, the Advertisement contains the Flags attribute and the device name.
 * The flag 0x06 indicates: LE General Discoverable Mode and BR/EDR not supported.
 */

/* LISTING_START(MainConfiguration): Init L2CAP SM ATT Server and start poll_timer timer */

static uint8_t g_rtcm_buf[RTCM_MESSAGE_SIZE];

struct mapkit_data_s
{
  btstack_context_callback_registration_t send_req;
  btstack_timer_source_t poll_timer;
  hci_con_handle_t con_handle;
  struct circbuf_s circ;

  /* uORB Subscribers */

  struct
  {
    /* GNSS Raw */

    struct
    {
      struct orb_object  obj;
      FAR struct pollfd *fds;
    } gnss;

  } sub;

  /* uORB Publishers */

  struct
  {
    /* RTCM Message */

    struct
    {
      struct rtcm_message_s data;
      int file;
    } rtcm;

    /* BTstack Status */

    struct
    {
      struct btstack_status_s data;
      int file;
    } btstack;

  } pub;
};

static struct mapkit_data_s g_mapkit_data;

const uint8_t adv_data[] =
{
  // Flags general discoverable, BR/EDR not supported
  2, BLUETOOTH_DATA_TYPE_FLAGS, 0x06,
  // Name
  8, BLUETOOTH_DATA_TYPE_COMPLETE_LOCAL_NAME, 'n', 'R', 'F',' ', 'S', 'P', 'P',
  // UUID ...
  17, BLUETOOTH_DATA_TYPE_COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS, 0x9e, 0xca, 0xdc, 0x24, 0xe, 0xe5, 0xa9, 0xe0, 0x93, 0xf3, 0xa3, 0xb5, 0x1, 0x0, 0x40, 0x6e,
};
const uint8_t adv_data_len = sizeof(adv_data);


/****************************************************************************
 * Name: sensor_subscribe
 ****************************************************************************/

static struct pollfd *sensor_subscribe(struct mapkit_data_s *priv,
                                       FAR const char *topic_name,
                                       float topic_rate,
                                       int topic_latency)
{
  struct orb_object *obj = &priv->sub.gnss.obj;
  FAR struct pollfd *fds;
  size_t len;
  int fd;

  /* Allocate poll data */

  fds = malloc(sizeof(struct pollfd));
  if (!fds)
    {
      return NULL;
    }

  /* calculate the inverval */

  float interval = topic_rate ? (1000000 / topic_rate) : 0;

  /* get the object meta */

  len = strlen(topic_name) - 1;
  obj->instance = topic_name[len] - '0';
  obj->meta = orb_get_meta(topic_name);

  /* subscribe to the topic */

  fd = orb_subscribe_multi(obj->meta, obj->instance);
  if (fd < 0)
    {
      free(fds);
      return NULL;
    }

  /* set the interval */

  if (interval != 0)
    {
      orb_set_interval(fd, (unsigned)interval);

      if (topic_latency != 0)
        {
          orb_set_batch_interval(fd, topic_latency);
        }
    }

  fds->fd = fd;
  fds->events = POLLIN;

  /* Update the subsciber data */

  priv->sub.gnss.fds = fds;

  return fds;
}

/****************************************************************************
 * Name: nordic_can_send
 ****************************************************************************/

static void nordic_can_send(void *context)
{
  struct mapkit_data_s *priv = (struct mapkit_data_s *)context;
  FAR uint8_t *buffer;
  size_t size;

  /* Send all saved data to the client */

  while (circbuf_used(&priv->circ))
    {
      /* Get the data chunk */

      buffer = circbuf_get_readptr(&priv->circ, &size);

      /* Send it to the client */

      nordic_spp_service_server_send(priv->con_handle, buffer, size);

      /* Inform we read it  */

      circbuf_readcommit(&priv->circ, size);
    }
}

/****************************************************************************
 * Name: uorb_ondata
 *
 * Description:
 *   Print topic data by its print_message callback.
 *
 * Input Parameters:
 *   meta         The uORB metadata.
 *   fd           Subscriber handle.
 *
 * Returned Value:
 *   0 on success copy, otherwise -1
 ****************************************************************************/

static int uorb_ondata(struct mapkit_data_s *priv,
                       FAR const struct orb_metadata *meta,
                       int fd)
{
  char buffer[meta->o_size];
  FAR struct sensor_gnss_raw *gnss = (FAR struct sensor_gnss_raw *)buffer;
  int ret;

  ret = orb_copy(meta, fd, buffer);
  if (priv && ret == OK)
    {
      /* Save all recevied data */

      if (circbuf_write(&priv->circ, gnss->buf, gnss->len) != gnss->len)
        {
          /* Reset buffer */

          circbuf_reset(&priv->circ);
        }

      /* Skip the read data */

      orb_ioctl(fd, SNIOC_SKIP_BUFFER,
                (unsigned long)(uintptr_t)&meta->o_size);
    }

  return ret;
}

/****************************************************************************
 * Name: sensor_poll
 ****************************************************************************/

static void sensor_poll(struct mapkit_data_s *priv)
{
  if (priv && priv->sub.gnss.fds != NULL)
    {
      struct orb_object *obj = &priv->sub.gnss.obj;
      FAR struct pollfd *fds =  priv->sub.gnss.fds;

      while (poll(fds, NPOLLFDS, POLL_DELAY_SEC) == NPOLLFDS)
        {
          if (fds->revents & POLLIN)
            {
              if (uorb_ondata(priv, obj->meta, fds->fd) < 0)
                {
                  break;
                }
            }
        }
    }
}

/****************************************************************************
 * Name: sensor_timer_handler
 ****************************************************************************/

static void sensor_timer_handler(struct btstack_timer_source *ts)
{
  struct mapkit_data_s *priv = (struct mapkit_data_s *)ts->context;

  if (priv->con_handle != HCI_CON_HANDLE_INVALID)
    {
      /* Poll the sensor */

      sensor_poll(priv);

      /* Trigger the send function */

      priv->send_req.context  = (void*)priv;
      priv->send_req.callback = &nordic_can_send;
      nordic_spp_service_server_request_can_send_now(&priv->send_req,
                                                      priv->con_handle);
    }

  /* Check the publish topic validity */

  if (priv->pub.btstack.file > 0)
    {
      /* Update the connection state */

      priv->pub.btstack.data.state = (priv->pub.btstack.data.rfcid != HCI_CON_HANDLE_INVALID);

      /* Publish the data */

      orb_publish(ORB_ID(btstack_status),
                  priv->pub.btstack.file,
                  &priv->pub.btstack.data);
    }

  /* Restart the timer */

  btstack_run_loop_set_timer(ts, POLL_PERIOD_MS);
  btstack_run_loop_add_timer(ts);
}

/****************************************************************************
 * Name: sensor_timer_setup
 ****************************************************************************/

static void sensor_timer_setup(void *context)
{
  struct mapkit_data_s *priv = (struct mapkit_data_s *)context;

  /* set one-shot timer */

  priv->poll_timer.process = &sensor_timer_handler;
  priv->poll_timer.context = context;
  btstack_run_loop_set_timer(&priv->poll_timer, POLL_PERIOD_MS);
  btstack_run_loop_add_timer(&priv->poll_timer);
}

/****************************************************************************
 * Name: nordic_spp_packet_handler
 ****************************************************************************/

static void nordic_spp_packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size)
{
  struct mapkit_data_s *priv = &g_mapkit_data;
  UNUSED(channel);

  switch (packet_type)
  {
    case HCI_EVENT_PACKET:
      if (hci_event_packet_get_type(packet) != HCI_EVENT_GATTSERVICE_META)
      {
        break;
      }

      switch (hci_event_gattservice_meta_get_subevent_code(packet))
      {
        case GATTSERVICE_SUBEVENT_SPP_SERVICE_CONNECTED:
          priv->con_handle = gattservice_subevent_spp_service_connected_get_con_handle(packet);
          printf("Connected with handle 0x%04x\n", priv->con_handle);

          /* Update the publish topic data */

          priv->pub.btstack.data.rfcid = priv->con_handle;
          priv->pub.btstack.data.rfmtu = 0;
          break;

        case GATTSERVICE_SUBEVENT_SPP_SERVICE_DISCONNECTED:
          printf("Disconnected with handle 0x%04x\n", priv->con_handle);
          priv->con_handle = HCI_CON_HANDLE_INVALID;

          /* Update the publish topic data */

          priv->pub.btstack.data.rfcid = HCI_CON_HANDLE_INVALID;
          priv->pub.btstack.data.rfmtu = 0;
          break;

        default:
          break;
      }
      break;

    case RFCOMM_DATA_PACKET:
#ifdef ENABLE_PRINTF_HEXDUMP
      printf_hexdump(packet, size);
#endif /* ENABLE_PRINTF_HEXDUMP */

      /* Check the publish topic validity */

      if (priv->pub.rtcm.file > 0)
        {
          /* Save the received data */

          memcpy(priv->pub.rtcm.data.msg,
                 packet,
                 priv->pub.rtcm.data.len = MIN(RTCM_MESSAGE_SIZE, size));

          /* Publish the data */

          orb_publish(ORB_ID(rtcm_message),
                      priv->pub.rtcm.file,
                      &priv->pub.rtcm.data);

          /* Send the RTCM data to the active GNSS device */

          orb_ioctl(priv->sub.gnss.fds->fd,
                    SNIOC_INJECT_DATA,
                    (unsigned long)(uintptr_t)&priv->pub.rtcm.data);
        }
      break;

    default:
      break;
  }
}

/****************************************************************************
 * Name: btstack_app
 ****************************************************************************/

int btstack_app(int argc, FAR char *argv[])
{
  struct mapkit_data_s *priv = &g_mapkit_data;
  int ret;

  (void)argc;
  (void)argv;

  /* Initialize the mapkit data */

  memset(priv, 0, sizeof(struct mapkit_data_s));

  /* Clear the connection handle */

  priv->con_handle = HCI_CON_HANDLE_INVALID;

  /* Allocate the GNSS data buffer */

  ret = circbuf_init(&priv->circ, NULL, GNSS_MSG_SIZE * GNSS_MSG_NUM);
  if (ret < 0)
    {
      fprintf(stderr, "ERROR: circbuf_init error\n");
      return EXIT_FAILURE;
    }

  /* Register the event topic(s) */

  if (!sensor_subscribe(priv, "sensor_gnss_raw0", 1000/POLL_PERIOD_MS, 0))
    {
      circbuf_uninit(&priv->circ);
      return EXIT_FAILURE;
    }

  /* Create the publish file for RTCM */

  priv->pub.rtcm.file = orb_advertise(ORB_ID(rtcm_message), 0);
  priv->pub.rtcm.data.msg = g_rtcm_buf;
  priv->pub.rtcm.data.len = 0;

  /* Create the publish file for BTstack */

  priv->pub.btstack.file = orb_advertise(ORB_ID(btstack_status), 0);
  priv->pub.btstack.data.rfcid = HCI_CON_HANDLE_INVALID;

  /* Configure the sensor poll timer */

  sensor_timer_setup((void*)priv);

  /* Initialize the BTstack */

  l2cap_init();

  /* Initialize LE Security Manager: Display only */

  sm_init();

  /* setup ATT server */

  att_server_init(profile_data, NULL, NULL);

  /* setup Nordic SPP service */

  nordic_spp_service_server_init(&nordic_spp_packet_handler);

  /* setup advertisements */

  uint16_t adv_int_min = 0x0030;
  uint16_t adv_int_max = 0x0030;
  uint8_t adv_type = 0;
  bd_addr_t null_addr;
  memset(null_addr, 0, 6);
  gap_advertisements_set_params(adv_int_min, adv_int_max, adv_type, 0, null_addr, 0x07, 0x00);
  gap_advertisements_set_data(adv_data_len, (uint8_t*) adv_data);
  gap_advertisements_enable(1);

  /* turn on! */

  hci_power_control(HCI_POWER_ON);

  return 0;
}
