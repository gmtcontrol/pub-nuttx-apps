diff --git a/src/common/pf_dcp.c b/src/common/pf_dcp.c
index aebf1a0..ae45ce1 100644
--- a/src/common/pf_dcp.c
+++ b/src/common/pf_dcp.c
@@ -1079,7 +1079,7 @@ static int pf_dcp_get_set (
             p_src[src_pos],
             p_src[src_pos + 1],
             false,
-            false);
+            NULL);
 
          /* Point to next block */
          src_pos += sizeof (uint8_t) + sizeof (uint8_t);
diff --git a/src/ports/nuttx/mib/lldpConfigManAddrTable.c b/src/ports/nuttx/mib/lldpConfigManAddrTable.c
new file mode 100644
index 0000000..b43022d
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpConfigManAddrTable.c
@@ -0,0 +1,173 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "lldpConfigManAddrTable.h"
+
+/** Initializes the lldpConfigManAddrTable module */
+void init_lldpConfigManAddrTable (pnet_t * pnet)
+{
+   /* here we initialize all the tables we're planning on supporting */
+   initialize_table_lldpConfigManAddrTable (pnet);
+}
+
+/** Initialize the lldpConfigManAddrTable table by defining its contents and how
+ * it's structured */
+void initialize_table_lldpConfigManAddrTable (pnet_t * pnet)
+{
+   const oid lldpConfigManAddrTable_oid[] = {1, 0, 8802, 1, 1, 2, 1, 1, 7};
+   const size_t lldpConfigManAddrTable_oid_len =
+      OID_LENGTH (lldpConfigManAddrTable_oid);
+   netsnmp_handler_registration * reg;
+   netsnmp_iterator_info * iinfo;
+   netsnmp_table_registration_info * table_info;
+
+   reg = netsnmp_create_handler_registration (
+      "lldpConfigManAddrTable",
+      lldpConfigManAddrTable_handler,
+      lldpConfigManAddrTable_oid,
+      lldpConfigManAddrTable_oid_len,
+      HANDLER_CAN_RONLY);
+
+   reg->my_reg_void = pnet;
+
+   table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
+   netsnmp_table_helper_add_indexes (
+      table_info,
+      ASN_INTEGER,   /* index: lldpLocManAddrSubtype */
+      ASN_OCTET_STR, /* index: lldpLocManAddr */
+      0);
+   table_info->min_column = COLUMN_LLDPCONFIGMANADDRPORTSTXENABLE;
+   table_info->max_column = COLUMN_LLDPCONFIGMANADDRPORTSTXENABLE;
+
+   iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
+   iinfo->get_first_data_point = lldpConfigManAddrTable_get_first_data_point;
+   iinfo->get_next_data_point = lldpConfigManAddrTable_get_next_data_point;
+   iinfo->table_reginfo = table_info;
+
+   iinfo->myvoid = pnet;
+
+   netsnmp_register_table_iterator (reg, iinfo);
+}
+
+netsnmp_variable_list * lldpConfigManAddrTable_get_first_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   netsnmp_variable_list * idx = put_index_data;
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_snmp_management_address_t address;
+
+   pf_snmp_get_management_address (pnet, &address);
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, address.subtype);
+   idx = idx->next_variable;
+
+   snmp_set_var_value (idx, &address.value[1], address.value[0]);
+
+   /* Set my_data_context to a value that is not NULL */
+   *my_data_context = (void *)(uintptr_t) true;
+
+   return put_index_data;
+}
+
+netsnmp_variable_list * lldpConfigManAddrTable_get_next_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   return NULL;
+}
+
+/** handles requests for the lldpConfigManAddrTable table */
+int lldpConfigManAddrTable_handler (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+
+   netsnmp_request_info * request;
+   netsnmp_table_request_info * table_info;
+   pnet_t * pnet = reginfo->my_reg_void;
+   void * my_data_context;
+   pf_lldp_port_list_t port_list;
+
+   switch (reqinfo->mode)
+   {
+      /*
+       * Read-support (also covers GetNext requests)
+       */
+   case MODE_GET:
+      for (request = requests; request; request = request->next)
+      {
+         my_data_context = netsnmp_extract_iterator_context (request);
+         table_info = netsnmp_extract_table_info (request);
+
+         LOG_DEBUG (
+            PF_SNMP_LOG,
+            "lldpConfigManAddrTable(%d): GET. Column number: %u\n",
+            __LINE__,
+            table_info->colnum);
+
+         switch (table_info->colnum)
+         {
+         case COLUMN_LLDPCONFIGMANADDRPORTSTXENABLE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            pf_snmp_get_port_list (pnet, &port_list);
+            snmp_set_var_typed_value (
+               request->requestvb,
+               ASN_OCTET_STR,
+               port_list.ports,
+               sizeof (port_list.ports));
+            break;
+         default:
+            netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
+            break;
+         }
+      }
+      break;
+   default:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpConfigManAddrTable(%d): Unknown mode: %u\n",
+         __LINE__,
+         reqinfo->mode);
+      break;
+   }
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/lldpConfigManAddrTable.h b/src/ports/nuttx/mib/lldpConfigManAddrTable.h
new file mode 100644
index 0000000..25e998b
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpConfigManAddrTable.h
@@ -0,0 +1,34 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+#ifndef LLDPCONFIGMANADDRTABLE_H
+#define LLDPCONFIGMANADDRTABLE_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_lldpConfigManAddrTable (pnet_t * pnet);
+void initialize_table_lldpConfigManAddrTable (pnet_t * pnet);
+Netsnmp_Node_Handler lldpConfigManAddrTable_handler;
+Netsnmp_First_Data_Point lldpConfigManAddrTable_get_first_data_point;
+Netsnmp_Next_Data_Point lldpConfigManAddrTable_get_next_data_point;
+
+/* column number definitions for table lldpConfigManAddrTable */
+#define COLUMN_LLDPCONFIGMANADDRPORTSTXENABLE 1
+#endif /* LLDPCONFIGMANADDRTABLE_H */
diff --git a/src/ports/nuttx/mib/lldpLocManAddrTable.c b/src/ports/nuttx/mib/lldpLocManAddrTable.c
new file mode 100644
index 0000000..06d130e
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpLocManAddrTable.c
@@ -0,0 +1,198 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "lldpLocManAddrTable.h"
+
+/** Initializes the lldpLocManAddrTable module */
+void init_lldpLocManAddrTable (pnet_t * pnet)
+{
+   /* here we initialize all the tables we're planning on supporting */
+   initialize_table_lldpLocManAddrTable (pnet);
+}
+
+/** Initialize the lldpLocManAddrTable table by defining its contents and how
+ * it's structured */
+void initialize_table_lldpLocManAddrTable (pnet_t * pnet)
+{
+   const oid lldpLocManAddrTable_oid[] = {1, 0, 8802, 1, 1, 2, 1, 3, 8};
+   const size_t lldpLocManAddrTable_oid_len =
+      OID_LENGTH (lldpLocManAddrTable_oid);
+   netsnmp_handler_registration * reg;
+   netsnmp_iterator_info * iinfo;
+   netsnmp_table_registration_info * table_info;
+
+   reg = netsnmp_create_handler_registration (
+      "lldpLocManAddrTable",
+      lldpLocManAddrTable_handler,
+      lldpLocManAddrTable_oid,
+      lldpLocManAddrTable_oid_len,
+      HANDLER_CAN_RONLY);
+
+   reg->my_reg_void = pnet;
+
+   table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
+   netsnmp_table_helper_add_indexes (
+      table_info,
+      ASN_INTEGER,   /* index: lldpLocManAddrSubtype */
+      ASN_OCTET_STR, /* index: lldpLocManAddr */
+      0);
+   table_info->min_column = COLUMN_LLDPLOCMANADDRLEN;
+   table_info->max_column = COLUMN_LLDPLOCMANADDROID;
+
+   iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
+   iinfo->get_first_data_point = lldpLocManAddrTable_get_first_data_point;
+   iinfo->get_next_data_point = lldpLocManAddrTable_get_next_data_point;
+   iinfo->table_reginfo = table_info;
+
+   iinfo->myvoid = pnet;
+
+   netsnmp_register_table_iterator (reg, iinfo);
+}
+
+netsnmp_variable_list * lldpLocManAddrTable_get_first_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   netsnmp_variable_list * idx = put_index_data;
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_snmp_management_address_t address;
+
+   pf_snmp_get_management_address (pnet, &address);
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, address.subtype);
+   idx = idx->next_variable;
+
+   snmp_set_var_value (idx, &address.value[1], address.value[0]);
+
+   /* Set my_data_context to a value that is not NULL */
+   *my_data_context = (void *)(uintptr_t) true;
+
+   return put_index_data;
+}
+
+netsnmp_variable_list * lldpLocManAddrTable_get_next_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   return NULL;
+}
+
+/** handles requests for the lldpLocManAddrTable table */
+int lldpLocManAddrTable_handler (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   netsnmp_request_info * request;
+   netsnmp_table_request_info * table_info;
+   pnet_t * pnet = reginfo->my_reg_void;
+   void * my_data_context;
+   pf_snmp_management_address_t address;
+   pf_lldp_interface_number_t port_index;
+
+   switch (reqinfo->mode)
+   {
+      /*
+       * Read-support (also covers GetNext requests)
+       */
+   case MODE_GET:
+      for (request = requests; request; request = request->next)
+      {
+         my_data_context = netsnmp_extract_iterator_context (request);
+         table_info = netsnmp_extract_table_info (request);
+
+         LOG_DEBUG (
+            PF_SNMP_LOG,
+            "lldpLocManAddrTable(%d): GET. Column number: %u\n",
+            __LINE__,
+            table_info->colnum);
+
+         switch (table_info->colnum)
+         {
+         case COLUMN_LLDPLOCMANADDRLEN:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            pf_snmp_get_management_address (pnet, &address);
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               address.len);
+            break;
+         case COLUMN_LLDPLOCMANADDRIFSUBTYPE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            pf_snmp_get_management_port_index (pnet, &port_index);
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               port_index.subtype);
+            break;
+         case COLUMN_LLDPLOCMANADDRIFID:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            pf_snmp_get_management_port_index (pnet, &port_index);
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               port_index.value);
+            break;
+         default:
+            netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
+            break;
+         }
+      }
+      break;
+   default:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpLocManAddrTable(%d): Unknown mode: %u\n",
+         __LINE__,
+         reqinfo->mode);
+      break;
+   }
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/lldpLocManAddrTable.h b/src/ports/nuttx/mib/lldpLocManAddrTable.h
new file mode 100644
index 0000000..8bfce8f
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpLocManAddrTable.h
@@ -0,0 +1,39 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+#ifndef LLDPLOCMANADDRTABLE_H
+#define LLDPLOCMANADDRTABLE_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_lldpLocManAddrTable (pnet_t * pnet);
+void initialize_table_lldpLocManAddrTable (pnet_t * pnet);
+Netsnmp_Node_Handler lldpLocManAddrTable_handler;
+Netsnmp_First_Data_Point lldpLocManAddrTable_get_first_data_point;
+Netsnmp_Next_Data_Point lldpLocManAddrTable_get_next_data_point;
+
+/* column number definitions for table lldpLocManAddrTable */
+#define COLUMN_LLDPLOCMANADDRSUBTYPE   1
+#define COLUMN_LLDPLOCMANADDR          2
+#define COLUMN_LLDPLOCMANADDRLEN       3
+#define COLUMN_LLDPLOCMANADDRIFSUBTYPE 4
+#define COLUMN_LLDPLOCMANADDRIFID      5
+#define COLUMN_LLDPLOCMANADDROID       6
+#endif /* LLDPLOCMANADDRTABLE_H */
diff --git a/src/ports/nuttx/mib/lldpLocPortTable.c b/src/ports/nuttx/mib/lldpLocPortTable.c
new file mode 100644
index 0000000..5fdf050
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpLocPortTable.c
@@ -0,0 +1,221 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "lldpLocPortTable.h"
+
+/** Initializes the lldpLocPortTable module */
+void init_lldpLocPortTable (pnet_t * pnet)
+{
+   /* here we initialize all the tables we're planning on supporting */
+   initialize_table_lldpLocPortTable (pnet);
+}
+
+static void lldpLocPortTable_loop_free (
+   void * loopctx,
+   netsnmp_iterator_info * iinfo)
+{
+   SNMP_FREE (loopctx);
+}
+
+/** Initialize the lldpLocPortTable table by defining its contents and how it's
+ * structured */
+void initialize_table_lldpLocPortTable (pnet_t * pnet)
+{
+   const oid lldpLocPortTable_oid[] = {1, 0, 8802, 1, 1, 2, 1, 3, 7};
+   const size_t lldpLocPortTable_oid_len = OID_LENGTH (lldpLocPortTable_oid);
+   netsnmp_handler_registration * reg;
+   netsnmp_iterator_info * iinfo;
+   netsnmp_table_registration_info * table_info;
+
+   reg = netsnmp_create_handler_registration (
+      "lldpLocPortTable",
+      lldpLocPortTable_handler,
+      lldpLocPortTable_oid,
+      lldpLocPortTable_oid_len,
+      HANDLER_CAN_RONLY);
+
+   reg->my_reg_void = pnet;
+
+   table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
+   netsnmp_table_helper_add_indexes (
+      table_info,
+      ASN_INTEGER, /* index: lldpLocPortNum */
+      0);
+   table_info->min_column = COLUMN_LLDPLOCPORTIDSUBTYPE;
+   table_info->max_column = COLUMN_LLDPLOCPORTDESC;
+
+   iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
+   iinfo->get_first_data_point = lldpLocPortTable_get_first_data_point;
+   iinfo->get_next_data_point = lldpLocPortTable_get_next_data_point;
+   iinfo->table_reginfo = table_info;
+
+   iinfo->free_loop_context_at_end = lldpLocPortTable_loop_free;
+   iinfo->myvoid = pnet;
+
+   netsnmp_register_table_iterator (reg, iinfo);
+}
+
+netsnmp_variable_list * lldpLocPortTable_get_first_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+
+   iterator = SNMP_MALLOC_TYPEDEF (pf_port_iterator_t);
+   pf_snmp_init_port_iterator (pnet, iterator);
+   *my_loop_context = iterator;
+
+   return lldpLocPortTable_get_next_data_point (
+      my_loop_context,
+      my_data_context,
+      put_index_data,
+      mydata);
+}
+
+netsnmp_variable_list * lldpLocPortTable_get_next_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   netsnmp_variable_list * idx = put_index_data;
+   pf_port_iterator_t * iterator;
+   int port;
+
+   iterator = (pf_port_iterator_t *)*my_loop_context;
+   port = pf_snmp_get_next_port (iterator);
+   if (port == 0)
+   {
+      return NULL;
+   }
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+
+   *my_data_context = (void *)(uintptr_t)port;
+   return put_index_data;
+}
+
+/** handles requests for the lldpLocPortTable table */
+int lldpLocPortTable_handler (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   netsnmp_request_info * request;
+   netsnmp_table_request_info * table_info;
+   pnet_t * pnet = reginfo->my_reg_void;
+   pf_lldp_port_id_t port_id;
+   pf_lldp_port_description_t port_desc;
+   void * my_data_context;
+   int port;
+
+   switch (reqinfo->mode)
+   {
+      /*
+       * Read-support (also covers GetNext requests)
+       */
+   case MODE_GET:
+      for (request = requests; request; request = request->next)
+      {
+         my_data_context = netsnmp_extract_iterator_context (request);
+         table_info = netsnmp_extract_table_info (request);
+
+         LOG_DEBUG (
+            PF_SNMP_LOG,
+            "lldpLocPortTable(%d): GET. Column number: %u\n",
+            __LINE__,
+            table_info->colnum);
+
+         switch (table_info->colnum)
+         {
+         case COLUMN_LLDPLOCPORTIDSUBTYPE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            pf_snmp_get_port_id (pnet, port, &port_id);
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               port_id.subtype);
+            break;
+         case COLUMN_LLDPLOCPORTID:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            pf_snmp_get_port_id (pnet, port, &port_id);
+            snmp_set_var_typed_value (
+               request->requestvb,
+               ASN_OCTET_STR,
+               port_id.string,
+               port_id.len);
+            break;
+         case COLUMN_LLDPLOCPORTDESC:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            pf_snmp_get_port_description (pnet, port, &port_desc);
+            snmp_set_var_typed_value (
+               request->requestvb,
+               ASN_OCTET_STR,
+               port_desc.string,
+               port_desc.len);
+            break;
+         default:
+            netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
+            break;
+         }
+      }
+      break;
+   default:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpLocPortTable(%d): Unknown mode: %u\n",
+         __LINE__,
+         reqinfo->mode);
+      break;
+   }
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/lldpLocPortTable.h b/src/ports/nuttx/mib/lldpLocPortTable.h
new file mode 100644
index 0000000..53a12fa
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpLocPortTable.h
@@ -0,0 +1,37 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+#ifndef LLDPLOCPORTTABLE_H
+#define LLDPLOCPORTTABLE_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_lldpLocPortTable (pnet_t * pnet);
+void initialize_table_lldpLocPortTable (pnet_t * pnet);
+Netsnmp_Node_Handler lldpLocPortTable_handler;
+Netsnmp_First_Data_Point lldpLocPortTable_get_first_data_point;
+Netsnmp_Next_Data_Point lldpLocPortTable_get_next_data_point;
+
+/* column number definitions for table lldpLocPortTable */
+#define COLUMN_LLDPLOCPORTNUM       1
+#define COLUMN_LLDPLOCPORTIDSUBTYPE 2
+#define COLUMN_LLDPLOCPORTID        3
+#define COLUMN_LLDPLOCPORTDESC      4
+#endif /* LLDPLOCPORTTABLE_H */
diff --git a/src/ports/nuttx/mib/lldpLocalSystemData.c b/src/ports/nuttx/mib/lldpLocalSystemData.c
new file mode 100644
index 0000000..cb3e2d4
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpLocalSystemData.c
@@ -0,0 +1,149 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.scalar.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "lldpLocalSystemData.h"
+
+/** Initializes the lldpLocalSystemData module */
+void init_lldpLocalSystemData (pnet_t * pnet)
+{
+   const oid lldpLocChassisIdSubtype_oid[] = {1, 0, 8802, 1, 1, 2, 1, 3, 1};
+   const oid lldpLocChassisId_oid[] = {1, 0, 8802, 1, 1, 2, 1, 3, 2};
+   netsnmp_handler_registration * reg;
+
+   netsnmp_register_scalar (
+      reg = netsnmp_create_handler_registration (
+         "lldpLocChassisIdSubtype",
+         handle_lldpLocChassisIdSubtype,
+         lldpLocChassisIdSubtype_oid,
+         OID_LENGTH (lldpLocChassisIdSubtype_oid),
+         HANDLER_CAN_RONLY));
+
+   reg->my_reg_void = pnet;
+
+   netsnmp_register_scalar (
+      reg = netsnmp_create_handler_registration (
+         "lldpLocChassisId",
+         handle_lldpLocChassisId,
+         lldpLocChassisId_oid,
+         OID_LENGTH (lldpLocChassisId_oid),
+         HANDLER_CAN_RONLY));
+
+   reg->my_reg_void = pnet;
+}
+
+int handle_lldpLocChassisIdSubtype (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   pnet_t * pnet = reginfo->my_reg_void;
+   pf_lldp_chassis_id_t chassis_id;
+
+   /* We are never called for a GETNEXT if it's registered as a
+      "instance", as it's "magically" handled for us.  */
+
+   /* a instance handler also only hands us one request at a time, so
+      we don't need to loop over a list of requests; we'll only get one. */
+
+   pf_snmp_get_chassis_id (pnet, &chassis_id);
+
+   switch (reqinfo->mode)
+   {
+
+   case MODE_GET:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpLocalSystemData(%d): GET chassis ID subtype.\n",
+         __LINE__);
+      snmp_set_var_typed_integer (
+         requests->requestvb,
+         ASN_INTEGER,
+         chassis_id.subtype);
+      break;
+
+   default:
+      /* we should never get here, so this is a really bad error */
+      LOG_ERROR (
+         PF_SNMP_LOG,
+         "lldpLocalSystemData(%d): unknown mode (%d)\n",
+         __LINE__,
+         reqinfo->mode);
+      return SNMP_ERR_GENERR;
+   }
+
+   return SNMP_ERR_NOERROR;
+}
+
+int handle_lldpLocChassisId (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   pnet_t * pnet = reginfo->my_reg_void;
+   pf_lldp_chassis_id_t chassis_id;
+
+   /* We are never called for a GETNEXT if it's registered as a
+      "instance", as it's "magically" handled for us.  */
+
+   /* a instance handler also only hands us one request at a time, so
+      we don't need to loop over a list of requests; we'll only get one. */
+
+   pf_snmp_get_chassis_id (pnet, &chassis_id);
+
+   switch (reqinfo->mode)
+   {
+
+   case MODE_GET:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpLocalSystemData(%d): GET chassis ID.\n",
+         __LINE__);
+
+      snmp_set_var_typed_value (
+         requests->requestvb,
+         ASN_OCTET_STR,
+         chassis_id.string,
+         chassis_id.len);
+      break;
+
+   default:
+      /* we should never get here, so this is a really bad error */
+      LOG_ERROR (
+         PF_SNMP_LOG,
+         "lldpLocalSystemData(%d): unknown mode (%d)\n",
+         __LINE__,
+         reqinfo->mode);
+      return SNMP_ERR_GENERR;
+   }
+
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/lldpLocalSystemData.h b/src/ports/nuttx/mib/lldpLocalSystemData.h
new file mode 100644
index 0000000..5c252c4
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpLocalSystemData.h
@@ -0,0 +1,34 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.scalar.conf
+ */
+#ifndef LLDPLOCALSYSTEMDATA_H
+#define LLDPLOCALSYSTEMDATA_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_lldpLocalSystemData (pnet_t * pnet);
+Netsnmp_Node_Handler handle_lldpLocChassisIdSubtype;
+Netsnmp_Node_Handler handle_lldpLocChassisId;
+Netsnmp_Node_Handler handle_lldpLocSysName;
+Netsnmp_Node_Handler handle_lldpLocSysDesc;
+Netsnmp_Node_Handler handle_lldpLocSysCapSupported;
+Netsnmp_Node_Handler handle_lldpLocSysCapEnabled;
+
+#endif /* LLDPLOCALSYSTEMDATA_H */
diff --git a/src/ports/nuttx/mib/lldpRemManAddrTable.c b/src/ports/nuttx/mib/lldpRemManAddrTable.c
new file mode 100644
index 0000000..2a7be69
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpRemManAddrTable.c
@@ -0,0 +1,250 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "lldpRemManAddrTable.h"
+
+/** Initializes the lldpRemManAddrTable module */
+void init_lldpRemManAddrTable (pnet_t * pnet)
+{
+   /* here we initialize all the tables we're planning on supporting */
+   initialize_table_lldpRemManAddrTable (pnet);
+}
+
+static void lldpRemManAddrTable_loop_free (
+   void * loopctx,
+   netsnmp_iterator_info * iinfo)
+{
+   SNMP_FREE (loopctx);
+}
+
+/** Initialize the lldpRemManAddrTable table by defining its contents and how
+ * it's structured */
+void initialize_table_lldpRemManAddrTable (pnet_t * pnet)
+{
+   const oid lldpRemManAddrTable_oid[] = {1, 0, 8802, 1, 1, 2, 1, 4, 2};
+   const size_t lldpRemManAddrTable_oid_len =
+      OID_LENGTH (lldpRemManAddrTable_oid);
+   netsnmp_handler_registration * reg;
+   netsnmp_iterator_info * iinfo;
+   netsnmp_table_registration_info * table_info;
+
+   reg = netsnmp_create_handler_registration (
+      "lldpRemManAddrTable",
+      lldpRemManAddrTable_handler,
+      lldpRemManAddrTable_oid,
+      lldpRemManAddrTable_oid_len,
+      HANDLER_CAN_RONLY);
+
+   reg->my_reg_void = pnet;
+
+   table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
+   netsnmp_table_helper_add_indexes (
+      table_info,
+      ASN_TIMETICKS, /* index: lldpRemTimeMark */
+      ASN_INTEGER,   /* index: lldpRemLocalPortNum */
+      ASN_INTEGER,   /* index: lldpRemIndex */
+      ASN_INTEGER,   /* index: lldpRemManAddrSubtype */
+      ASN_OCTET_STR, /* index: lldpRemManAddr */
+      0);
+   table_info->min_column = COLUMN_LLDPREMMANADDRIFSUBTYPE;
+   table_info->max_column = COLUMN_LLDPREMMANADDROID;
+
+   iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
+   iinfo->get_first_data_point = lldpRemManAddrTable_get_first_data_point;
+   iinfo->get_next_data_point = lldpRemManAddrTable_get_next_data_point;
+   iinfo->table_reginfo = table_info;
+
+   iinfo->free_loop_context_at_end = lldpRemManAddrTable_loop_free;
+   iinfo->myvoid = pnet;
+
+   netsnmp_register_table_iterator (reg, iinfo);
+}
+
+netsnmp_variable_list * lldpRemManAddrTable_get_first_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+
+   iterator = SNMP_MALLOC_TYPEDEF (pf_port_iterator_t);
+   pf_snmp_init_port_iterator (pnet, iterator);
+   *my_loop_context = iterator;
+
+   return lldpRemManAddrTable_get_next_data_point (
+      my_loop_context,
+      my_data_context,
+      put_index_data,
+      mydata);
+}
+
+netsnmp_variable_list * lldpRemManAddrTable_get_next_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   netsnmp_variable_list * idx = put_index_data;
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+   int port;
+   uint32_t timestamp;
+   pf_snmp_management_address_t address;
+   int error;
+
+   iterator = (pf_port_iterator_t *)*my_loop_context;
+
+   do
+   {
+      port = pf_snmp_get_next_port (iterator);
+      if (port == 0)
+      {
+         return NULL;
+      }
+
+      error = pf_snmp_get_peer_timestamp (pnet, port, &timestamp);
+      if (error == 0)
+      {
+         error = pf_snmp_get_peer_management_address (pnet, port, &address);
+      }
+   } while (error);
+
+   snmp_set_var_typed_integer (idx, ASN_TIMETICKS, timestamp);
+   idx = idx->next_variable;
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+   idx = idx->next_variable;
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+   idx = idx->next_variable;
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, address.subtype);
+   idx = idx->next_variable;
+
+   snmp_set_var_value (idx, &address.value[1], address.value[0]);
+
+   *my_data_context = (void *)(uintptr_t)port;
+   return put_index_data;
+}
+
+/** handles requests for the lldpRemManAddrTable table */
+int lldpRemManAddrTable_handler (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   netsnmp_request_info * request;
+   netsnmp_table_request_info * table_info;
+   pnet_t * pnet = reginfo->my_reg_void;
+   void * my_data_context;
+   pf_lldp_interface_number_t port_index;
+   int port;
+   int error;
+
+   switch (reqinfo->mode)
+   {
+      /*
+       * Read-support (also covers GetNext requests)
+       */
+   case MODE_GET:
+      for (request = requests; request; request = request->next)
+      {
+         my_data_context = netsnmp_extract_iterator_context (request);
+         table_info = netsnmp_extract_table_info (request);
+
+         LOG_DEBUG (
+            PF_SNMP_LOG,
+            "lldpRemManAddrTable(%d): GET. Column number: %u\n",
+            __LINE__,
+            table_info->colnum);
+
+         switch (table_info->colnum)
+         {
+         case COLUMN_LLDPREMMANADDRIFSUBTYPE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error =
+               pf_snmp_get_peer_management_port_index (pnet, port, &port_index);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               port_index.subtype);
+            break;
+         case COLUMN_LLDPREMMANADDRIFID:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error =
+               pf_snmp_get_peer_management_port_index (pnet, port, &port_index);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               port_index.value);
+            break;
+         default:
+            netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
+            break;
+         }
+      }
+      break;
+   default:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpRemManAddrTable(%d): Unknown mode: %u\n",
+         __LINE__,
+         reqinfo->mode);
+      break;
+   }
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/lldpRemManAddrTable.h b/src/ports/nuttx/mib/lldpRemManAddrTable.h
new file mode 100644
index 0000000..f375546
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpRemManAddrTable.h
@@ -0,0 +1,38 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+#ifndef LLDPREMMANADDRTABLE_H
+#define LLDPREMMANADDRTABLE_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_lldpRemManAddrTable (pnet_t * pnet);
+void initialize_table_lldpRemManAddrTable (pnet_t * pnet);
+Netsnmp_Node_Handler lldpRemManAddrTable_handler;
+Netsnmp_First_Data_Point lldpRemManAddrTable_get_first_data_point;
+Netsnmp_Next_Data_Point lldpRemManAddrTable_get_next_data_point;
+
+/* column number definitions for table lldpRemManAddrTable */
+#define COLUMN_LLDPREMMANADDRSUBTYPE   1
+#define COLUMN_LLDPREMMANADDR          2
+#define COLUMN_LLDPREMMANADDRIFSUBTYPE 3
+#define COLUMN_LLDPREMMANADDRIFID      4
+#define COLUMN_LLDPREMMANADDROID       5
+#endif /* LLDPREMMANADDRTABLE_H */
diff --git a/src/ports/nuttx/mib/lldpRemTable.c b/src/ports/nuttx/mib/lldpRemTable.c
new file mode 100644
index 0000000..a432f3a
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpRemTable.c
@@ -0,0 +1,300 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "lldpRemTable.h"
+
+/** Initializes the lldpRemTable module */
+void init_lldpRemTable (pnet_t * pnet)
+{
+   /* here we initialize all the tables we're planning on supporting */
+   initialize_table_lldpRemTable (pnet);
+}
+
+static void lldpRemTable_loop_free (
+   void * loopctx,
+   netsnmp_iterator_info * iinfo)
+{
+   SNMP_FREE (loopctx);
+}
+
+/** Initialize the lldpRemTable table by defining its contents and how it's
+ * structured */
+void initialize_table_lldpRemTable (pnet_t * pnet)
+{
+   const oid lldpRemTable_oid[] = {1, 0, 8802, 1, 1, 2, 1, 4, 1};
+   const size_t lldpRemTable_oid_len = OID_LENGTH (lldpRemTable_oid);
+   netsnmp_handler_registration * reg;
+   netsnmp_iterator_info * iinfo;
+   netsnmp_table_registration_info * table_info;
+
+   reg = netsnmp_create_handler_registration (
+      "lldpRemTable",
+      lldpRemTable_handler,
+      lldpRemTable_oid,
+      lldpRemTable_oid_len,
+      HANDLER_CAN_RONLY);
+
+   reg->my_reg_void = pnet;
+
+   table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
+   netsnmp_table_helper_add_indexes (
+      table_info,
+      ASN_TIMETICKS, /* index: lldpRemTimeMark */
+      ASN_INTEGER,   /* index: lldpRemLocalPortNum */
+      ASN_INTEGER,   /* index: lldpRemIndex */
+      0);
+   table_info->min_column = COLUMN_LLDPREMCHASSISIDSUBTYPE;
+   table_info->max_column = COLUMN_LLDPREMSYSCAPENABLED;
+
+   iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
+   iinfo->get_first_data_point = lldpRemTable_get_first_data_point;
+   iinfo->get_next_data_point = lldpRemTable_get_next_data_point;
+   iinfo->table_reginfo = table_info;
+
+   iinfo->free_loop_context_at_end = lldpRemTable_loop_free;
+   iinfo->myvoid = pnet;
+
+   netsnmp_register_table_iterator (reg, iinfo);
+}
+
+netsnmp_variable_list * lldpRemTable_get_first_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+
+   iterator = SNMP_MALLOC_TYPEDEF (pf_port_iterator_t);
+   pf_snmp_init_port_iterator (pnet, iterator);
+   *my_loop_context = iterator;
+
+   return lldpRemTable_get_next_data_point (
+      my_loop_context,
+      my_data_context,
+      put_index_data,
+      mydata);
+}
+
+netsnmp_variable_list * lldpRemTable_get_next_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   netsnmp_variable_list * idx = put_index_data;
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+   int port;
+   uint32_t timestamp;
+   int error;
+
+   iterator = (pf_port_iterator_t *)*my_loop_context;
+
+   do
+   {
+      port = pf_snmp_get_next_port (iterator);
+      if (port == 0)
+      {
+         return NULL;
+      }
+
+      error = pf_snmp_get_peer_timestamp (pnet, port, &timestamp);
+   } while (error);
+
+   snmp_set_var_typed_integer (idx, ASN_TIMETICKS, timestamp);
+   idx = idx->next_variable;
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+   idx = idx->next_variable;
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+
+   *my_data_context = (void *)(uintptr_t)port;
+   return put_index_data;
+}
+
+/** handles requests for the lldpRemTable table */
+int lldpRemTable_handler (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+
+   netsnmp_request_info * request;
+   netsnmp_table_request_info * table_info;
+   pnet_t * pnet = reginfo->my_reg_void;
+   void * my_data_context;
+   pf_lldp_chassis_id_t chassis_id;
+   pf_lldp_port_id_t port_id;
+   pf_lldp_port_description_t port_desc;
+   int port;
+   int error;
+
+   switch (reqinfo->mode)
+   {
+      /*
+       * Read-support (also covers GetNext requests)
+       */
+   case MODE_GET:
+      for (request = requests; request; request = request->next)
+      {
+         my_data_context = netsnmp_extract_iterator_context (request);
+         table_info = netsnmp_extract_table_info (request);
+
+         LOG_DEBUG (
+            PF_SNMP_LOG,
+            "lldpRemTable(%d): GET. Column number: %u\n",
+            __LINE__,
+            table_info->colnum);
+
+         switch (table_info->colnum)
+         {
+         case COLUMN_LLDPREMCHASSISIDSUBTYPE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_chassis_id (pnet, port, &chassis_id);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               chassis_id.subtype);
+            break;
+         case COLUMN_LLDPREMCHASSISID:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_chassis_id (pnet, port, &chassis_id);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_value (
+               request->requestvb,
+               ASN_OCTET_STR,
+               chassis_id.string,
+               chassis_id.len);
+            break;
+         case COLUMN_LLDPREMPORTIDSUBTYPE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_port_id (pnet, port, &port_id);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               port_id.subtype);
+            break;
+         case COLUMN_LLDPREMPORTID:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_port_id (pnet, port, &port_id);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_value (
+               request->requestvb,
+               ASN_OCTET_STR,
+               port_id.string,
+               port_id.len);
+            break;
+         case COLUMN_LLDPREMPORTDESC:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_port_description (pnet, port, &port_desc);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_value (
+               request->requestvb,
+               ASN_OCTET_STR,
+               port_desc.string,
+               port_desc.len);
+            break;
+         default:
+            netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
+            break;
+         }
+      }
+      break;
+   default:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpRemTable(%d): Unknown mode: %u\n",
+         __LINE__,
+         reqinfo->mode);
+      break;
+   }
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/lldpRemTable.h b/src/ports/nuttx/mib/lldpRemTable.h
new file mode 100644
index 0000000..8bca6a4
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpRemTable.h
@@ -0,0 +1,45 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+#ifndef LLDPREMTABLE_H
+#define LLDPREMTABLE_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_lldpRemTable (pnet_t * pnet);
+void initialize_table_lldpRemTable (pnet_t * pnet);
+Netsnmp_Node_Handler lldpRemTable_handler;
+Netsnmp_First_Data_Point lldpRemTable_get_first_data_point;
+Netsnmp_Next_Data_Point lldpRemTable_get_next_data_point;
+
+/* column number definitions for table lldpRemTable */
+#define COLUMN_LLDPREMTIMEMARK         1
+#define COLUMN_LLDPREMLOCALPORTNUM     2
+#define COLUMN_LLDPREMINDEX            3
+#define COLUMN_LLDPREMCHASSISIDSUBTYPE 4
+#define COLUMN_LLDPREMCHASSISID        5
+#define COLUMN_LLDPREMPORTIDSUBTYPE    6
+#define COLUMN_LLDPREMPORTID           7
+#define COLUMN_LLDPREMPORTDESC         8
+#define COLUMN_LLDPREMSYSNAME          9
+#define COLUMN_LLDPREMSYSDESC          10
+#define COLUMN_LLDPREMSYSCAPSUPPORTED  11
+#define COLUMN_LLDPREMSYSCAPENABLED    12
+#endif /* LLDPREMTABLE_H */
diff --git a/src/ports/nuttx/mib/lldpXPnoLocTable.c b/src/ports/nuttx/mib/lldpXPnoLocTable.c
new file mode 100644
index 0000000..f7fdd0b
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpXPnoLocTable.c
@@ -0,0 +1,233 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "lldpXPnoLocTable.h"
+
+/** Initializes the lldpXPnoLocTable module */
+void init_lldpXPnoLocTable (pnet_t * pnet)
+{
+   /* here we initialize all the tables we're planning on supporting */
+   initialize_table_lldpXPnoLocTable (pnet);
+}
+
+static void lldpXPnoLocTable_loop_free (
+   void * loopctx,
+   netsnmp_iterator_info * iinfo)
+{
+   SNMP_FREE (loopctx);
+}
+
+/** Initialize the lldpXPnoLocTable table by defining its contents and how it's
+ * structured */
+void initialize_table_lldpXPnoLocTable (pnet_t * pnet)
+{
+   const oid lldpXPnoLocTable_oid[] = {1, 0, 8802, 1, 1, 2, 1, 5, 3791, 1, 2, 1};
+   const size_t lldpXPnoLocTable_oid_len = OID_LENGTH (lldpXPnoLocTable_oid);
+   netsnmp_handler_registration * reg;
+   netsnmp_iterator_info * iinfo;
+   netsnmp_table_registration_info * table_info;
+
+   reg = netsnmp_create_handler_registration (
+      "lldpXPnoLocTable",
+      lldpXPnoLocTable_handler,
+      lldpXPnoLocTable_oid,
+      lldpXPnoLocTable_oid_len,
+      HANDLER_CAN_RONLY);
+
+   reg->my_reg_void = pnet;
+
+   table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
+   netsnmp_table_helper_add_indexes (
+      table_info,
+      ASN_INTEGER, /* index: lldpLocPortNum */
+      0);
+   table_info->min_column = COLUMN_LLDPXPNOLOCLPDVALUE;
+   table_info->max_column = COLUMN_LLDPXPNOLOCPORTMRPICDOMAINID;
+
+   iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
+   iinfo->get_first_data_point = lldpXPnoLocTable_get_first_data_point;
+   iinfo->get_next_data_point = lldpXPnoLocTable_get_next_data_point;
+   iinfo->table_reginfo = table_info;
+
+   iinfo->free_loop_context_at_end = lldpXPnoLocTable_loop_free;
+   iinfo->myvoid = pnet;
+
+   netsnmp_register_table_iterator (reg, iinfo);
+}
+
+netsnmp_variable_list * lldpXPnoLocTable_get_first_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+
+   iterator = SNMP_MALLOC_TYPEDEF (pf_port_iterator_t);
+   pf_snmp_init_port_iterator (pnet, iterator);
+   *my_loop_context = iterator;
+
+   return lldpXPnoLocTable_get_next_data_point (
+      my_loop_context,
+      my_data_context,
+      put_index_data,
+      mydata);
+}
+
+netsnmp_variable_list * lldpXPnoLocTable_get_next_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   netsnmp_variable_list * idx = put_index_data;
+   pf_port_iterator_t * iterator;
+   int port;
+
+   iterator = (pf_port_iterator_t *)*my_loop_context;
+   port = pf_snmp_get_next_port (iterator);
+   if (port == 0)
+   {
+      return NULL;
+   }
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+
+   *my_data_context = (void *)(uintptr_t)port;
+   return put_index_data;
+}
+
+/** handles requests for the lldpXPnoLocTable table */
+int lldpXPnoLocTable_handler (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   netsnmp_request_info * request;
+   netsnmp_table_request_info * table_info;
+   pnet_t * pnet = reginfo->my_reg_void;
+   void * my_data_context;
+   pf_snmp_signal_delay_t delays;
+   pf_lldp_station_name_t station_name;
+   int port;
+
+   switch (reqinfo->mode)
+   {
+      /*
+       * Read-support (also covers GetNext requests)
+       */
+   case MODE_GET:
+      for (request = requests; request; request = request->next)
+      {
+         my_data_context = netsnmp_extract_iterator_context (request);
+         table_info = netsnmp_extract_table_info (request);
+
+         LOG_DEBUG (
+            PF_SNMP_LOG,
+            "lldpXPnoLocTable(%d): GET. Column number: %u\n",
+            __LINE__,
+            table_info->colnum);
+
+         switch (table_info->colnum)
+         {
+         case COLUMN_LLDPXPNOLOCLPDVALUE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            pf_snmp_get_signal_delays (pnet, port, &delays);
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_UNSIGNED,
+               delays.line_propagation_delay_ns);
+            break;
+         case COLUMN_LLDPXPNOLOCPORTTXDVALUE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            pf_snmp_get_signal_delays (pnet, port, &delays);
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_UNSIGNED,
+               delays.port_tx_delay_ns);
+            break;
+         case COLUMN_LLDPXPNOLOCPORTRXDVALUE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            pf_snmp_get_signal_delays (pnet, port, &delays);
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_UNSIGNED,
+               delays.port_rx_delay_ns);
+            break;
+         case COLUMN_LLDPXPNOLOCPORTNOS:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            pf_snmp_get_station_name (pnet, &station_name);
+            snmp_set_var_typed_value (
+               request->requestvb,
+               ASN_OCTET_STR,
+               station_name.string,
+               station_name.len);
+            break;
+         default:
+            netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
+            break;
+         }
+      }
+      break;
+   default:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpXPnoLocTable(%d): Unknown mode: %u\n",
+         __LINE__,
+         reqinfo->mode);
+      break;
+   }
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/lldpXPnoLocTable.h b/src/ports/nuttx/mib/lldpXPnoLocTable.h
new file mode 100644
index 0000000..4c10b9c
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpXPnoLocTable.h
@@ -0,0 +1,61 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+#ifndef LLDPXPNOLOCTABLE_H
+#define LLDPXPNOLOCTABLE_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_lldpXPnoLocTable (pnet_t * pnet);
+void initialize_table_lldpXPnoLocTable (pnet_t * pnet);
+Netsnmp_Node_Handler lldpXPnoLocTable_handler;
+Netsnmp_First_Data_Point lldpXPnoLocTable_get_first_data_point;
+Netsnmp_Next_Data_Point lldpXPnoLocTable_get_next_data_point;
+
+/* column number definitions for table lldpXPnoLocTable */
+#define COLUMN_LLDPXPNOLOCLPDVALUE                                 1
+#define COLUMN_LLDPXPNOLOCPORTTXDVALUE                             2
+#define COLUMN_LLDPXPNOLOCPORTRXDVALUE                             3
+#define COLUMN_LLDPXPNOLOCPORTSTATUSRT2                            4
+#define COLUMN_LLDPXPNOLOCPORTSTATUSRT3                            5
+#define COLUMN_LLDPXPNOLOCPORTNOS                                  6
+#define COLUMN_LLDPXPNOLOCPORTMRPUUID                              7
+#define COLUMN_LLDPXPNOLOCPORTMRRTSTATUS                           8
+#define COLUMN_LLDPXPNOLOCPORTPTCPMASTER                           9
+#define COLUMN_LLDPXPNOLOCPORTPTCPSUBDOMAINUUID                    10
+#define COLUMN_LLDPXPNOLOCPORTPTCPIRDATAUUID                       11
+#define COLUMN_LLDPXPNOLOCPORTMODERT3                              12
+#define COLUMN_LLDPXPNOLOCPORTPERIODLENGTH                         13
+#define COLUMN_LLDPXPNOLOCPORTPERIODVALIDITY                       14
+#define COLUMN_LLDPXPNOLOCPORTREDOFFSET                            15
+#define COLUMN_LLDPXPNOLOCPORTREDVALIDITY                          16
+#define COLUMN_LLDPXPNOLOCPORTORANGEOFFSET                         17
+#define COLUMN_LLDPXPNOLOCPORTORANGEVALIDITY                       18
+#define COLUMN_LLDPXPNOLOCPORTGREENOFFSET                          19
+#define COLUMN_LLDPXPNOLOCPORTGREENVALIDITY                        20
+#define COLUMN_LLDPXPNOLOCPORTSTATUSRT3OPTIMIZATIONSUPPORTED       21
+#define COLUMN_LLDPXPNOLOCPORTSTATUSRT3PREAMBLESHORTENINGSUPPORTED 22
+#define COLUMN_LLDPXPNOLOCPORTSTATUSRT3PREAMBLESHORTENING          23
+#define COLUMN_LLDPXPNOLOCPORTSTATUSRT3FRAGMENTATIONSUPPORTED      24
+#define COLUMN_LLDPXPNOLOCPORTSTATUSRT3FRAGMENTATION               25
+#define COLUMN_LLDPXPNOLOCPORTOPERMAUTYPEEXTENSION                 26
+#define COLUMN_LLDPXPNOLOCPORTMRPICROLE                            27
+#define COLUMN_LLDPXPNOLOCPORTMRPICDOMAINID                        28
+#endif /* LLDPXPNOLOCTABLE_H */
diff --git a/src/ports/nuttx/mib/lldpXPnoRemTable.c b/src/ports/nuttx/mib/lldpXPnoRemTable.c
new file mode 100644
index 0000000..952a5f6
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpXPnoRemTable.c
@@ -0,0 +1,273 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "lldpXPnoRemTable.h"
+
+/** Initializes the lldpXdot3RemPortTable module */
+void init_lldpXPnoRemTable (pnet_t * pnet)
+{
+   /* here we initialize all the tables we're planning on supporting */
+   initialize_table_lldpXPnoRemTable (pnet);
+}
+
+static void lldpXPnoRemTable_loop_free (
+   void * loopctx,
+   netsnmp_iterator_info * iinfo)
+{
+   SNMP_FREE (loopctx);
+}
+
+/** Initialize the lldpXPnoRemTable table by defining its contents and how it's
+ * structured */
+void initialize_table_lldpXPnoRemTable (pnet_t * pnet)
+{
+   const oid lldpXPnoRemTable_oid[] = {1, 0, 8802, 1, 1, 2, 1, 5, 3791, 1, 3, 1};
+   const size_t lldpXPnoRemTable_oid_len = OID_LENGTH (lldpXPnoRemTable_oid);
+   netsnmp_handler_registration * reg;
+   netsnmp_iterator_info * iinfo;
+   netsnmp_table_registration_info * table_info;
+
+   reg = netsnmp_create_handler_registration (
+      "lldpXPnoRemTable",
+      lldpXPnoRemTable_handler,
+      lldpXPnoRemTable_oid,
+      lldpXPnoRemTable_oid_len,
+      HANDLER_CAN_RONLY);
+
+   reg->my_reg_void = pnet;
+
+   table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
+   netsnmp_table_helper_add_indexes (
+      table_info,
+      ASN_TIMETICKS, /* index: lldpRemTimeMark */
+      ASN_INTEGER,   /* index: lldpRemLocalPortNum */
+      ASN_INTEGER,   /* index: lldpRemIndex */
+      0);
+   table_info->min_column = COLUMN_LLDPXPNOREMLPDVALUE;
+   table_info->max_column = COLUMN_LLDPXPNOREMPORTMRPICDOMAINID;
+
+   iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
+   iinfo->get_first_data_point = lldpXPnoRemTable_get_first_data_point;
+   iinfo->get_next_data_point = lldpXPnoRemTable_get_next_data_point;
+   iinfo->table_reginfo = table_info;
+
+   iinfo->free_loop_context_at_end = lldpXPnoRemTable_loop_free;
+   iinfo->myvoid = pnet;
+
+   netsnmp_register_table_iterator (reg, iinfo);
+}
+
+netsnmp_variable_list * lldpXPnoRemTable_get_first_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+
+   iterator = SNMP_MALLOC_TYPEDEF (pf_port_iterator_t);
+   pf_snmp_init_port_iterator (pnet, iterator);
+   *my_loop_context = iterator;
+
+   return lldpXPnoRemTable_get_next_data_point (
+      my_loop_context,
+      my_data_context,
+      put_index_data,
+      mydata);
+}
+
+netsnmp_variable_list * lldpXPnoRemTable_get_next_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   netsnmp_variable_list * idx = put_index_data;
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+   int port;
+   uint32_t timestamp;
+   int error;
+
+   iterator = (pf_port_iterator_t *)*my_loop_context;
+
+   do
+   {
+      port = pf_snmp_get_next_port (iterator);
+      if (port == 0)
+      {
+         return NULL;
+      }
+
+      error = pf_snmp_get_peer_timestamp (pnet, port, &timestamp);
+   } while (error);
+
+   snmp_set_var_typed_integer (idx, ASN_TIMETICKS, timestamp);
+   idx = idx->next_variable;
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+   idx = idx->next_variable;
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+
+   *my_data_context = (void *)(uintptr_t)port;
+   return put_index_data;
+}
+
+/** handles requests for the lldpXPnoRemTable table */
+int lldpXPnoRemTable_handler (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+
+   netsnmp_request_info * request;
+   netsnmp_table_request_info * table_info;
+   pnet_t * pnet = reginfo->my_reg_void;
+   void * my_data_context;
+   pf_snmp_signal_delay_t delays;
+   pf_lldp_station_name_t station_name;
+   int port;
+   int error;
+
+   switch (reqinfo->mode)
+   {
+      /*
+       * Read-support (also covers GetNext requests)
+       */
+   case MODE_GET:
+      for (request = requests; request; request = request->next)
+      {
+         my_data_context = netsnmp_extract_iterator_context (request);
+         table_info = netsnmp_extract_table_info (request);
+
+         LOG_DEBUG (
+            PF_SNMP_LOG,
+            "lldpXPnoRemTable(%d): GET. Column number: %u\n",
+            __LINE__,
+            table_info->colnum);
+
+         switch (table_info->colnum)
+         {
+         case COLUMN_LLDPXPNOREMLPDVALUE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_signal_delays (pnet, port, &delays);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_UNSIGNED,
+               delays.line_propagation_delay_ns);
+            break;
+         case COLUMN_LLDPXPNOREMPORTTXDVALUE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_signal_delays (pnet, port, &delays);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_UNSIGNED,
+               delays.port_tx_delay_ns);
+            break;
+         case COLUMN_LLDPXPNOREMPORTRXDVALUE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_signal_delays (pnet, port, &delays);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_UNSIGNED,
+               delays.port_rx_delay_ns);
+            break;
+         case COLUMN_LLDPXPNOREMPORTNOS:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_station_name (pnet, port, &station_name);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+            snmp_set_var_typed_value (
+               request->requestvb,
+               ASN_OCTET_STR,
+               station_name.string,
+               station_name.len);
+            break;
+         default:
+            netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
+            break;
+         }
+      }
+      break;
+   default:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpXPnoRemTable(%d): Unknown mode: %u\n",
+         __LINE__,
+         reqinfo->mode);
+      break;
+   }
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/lldpXPnoRemTable.h b/src/ports/nuttx/mib/lldpXPnoRemTable.h
new file mode 100644
index 0000000..e42bc6d
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpXPnoRemTable.h
@@ -0,0 +1,58 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+#ifndef LLDPXPNOREMTABLE_H
+#define LLDPXPNOREMTABLE_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_lldpXPnoRemTable (pnet_t * pnet);
+void initialize_table_lldpXPnoRemTable (pnet_t * pnet);
+Netsnmp_Node_Handler lldpXPnoRemTable_handler;
+Netsnmp_First_Data_Point lldpXPnoRemTable_get_first_data_point;
+Netsnmp_Next_Data_Point lldpXPnoRemTable_get_next_data_point;
+
+/* column number definitions for table lldpXPnoRemTable */
+#define COLUMN_LLDPXPNOREMLPDVALUE                        1
+#define COLUMN_LLDPXPNOREMPORTTXDVALUE                    2
+#define COLUMN_LLDPXPNOREMPORTRXDVALUE                    3
+#define COLUMN_LLDPXPNOREMPORTSTATUSRT2                   4
+#define COLUMN_LLDPXPNOREMPORTSTATUSRT3                   5
+#define COLUMN_LLDPXPNOREMPORTNOS                         6
+#define COLUMN_LLDPXPNOREMPORTMRPUUID                     7
+#define COLUMN_LLDPXPNOREMPORTMRRTSTATUS                  8
+#define COLUMN_LLDPXPNOREMPORTPTCPMASTER                  9
+#define COLUMN_LLDPXPNOREMPORTPTCPSUBDOMAINUUID           10
+#define COLUMN_LLDPXPNOREMPORTPTCPIRDATAUUID              11
+#define COLUMN_LLDPXPNOREMPORTMODERT3                     12
+#define COLUMN_LLDPXPNOREMPORTPERIODLENGTH                13
+#define COLUMN_LLDPXPNOREMPORTPERIODVALIDITY              14
+#define COLUMN_LLDPXPNOREMPORTREDOFFSET                   15
+#define COLUMN_LLDPXPNOREMPORTREDVALIDITY                 16
+#define COLUMN_LLDPXPNOREMPORTORANGEOFFSET                17
+#define COLUMN_LLDPXPNOREMPORTORANGEVALIDITY              18
+#define COLUMN_LLDPXPNOREMPORTGREENOFFSET                 19
+#define COLUMN_LLDPXPNOREMPORTGREENVALIDITY               20
+#define COLUMN_LLDPXPNOREMPORTSTATUSRT3PREAMBLESHORTENING 21
+#define COLUMN_LLDPXPNOREMPORTSTATUSRT3FRAGMENTATION      22
+#define COLUMN_LLDPXPNOREMPORTOPERMAUTYPEEXTENSION        23
+#define COLUMN_LLDPXPNOREMPORTMRPICROLE                   24
+#define COLUMN_LLDPXPNOREMPORTMRPICDOMAINID               25
+#endif /* LLDPXPNOREMTABLE_H */
diff --git a/src/ports/nuttx/mib/lldpXdot3LocPortTable.c b/src/ports/nuttx/mib/lldpXdot3LocPortTable.c
new file mode 100644
index 0000000..bad6e63
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpXdot3LocPortTable.c
@@ -0,0 +1,235 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "lldpXdot3LocPortTable.h"
+
+/** Initializes the lldpXdot3LocPortTable module */
+void init_lldpXdot3LocPortTable (pnet_t * pnet)
+{
+   /* here we initialize all the tables we're planning on supporting */
+   initialize_table_lldpXdot3LocPortTable (pnet);
+}
+
+static void lldpXdot3LocPortTable_loop_free (
+   void * loopctx,
+   netsnmp_iterator_info * iinfo)
+{
+   SNMP_FREE (loopctx);
+}
+
+/** Initialize the lldpXdot3LocPortTable table by defining its contents and how
+ * it's structured */
+void initialize_table_lldpXdot3LocPortTable (pnet_t * pnet)
+{
+   const oid lldpXdot3LocPortTable_oid[] =
+      {1, 0, 8802, 1, 1, 2, 1, 5, 4623, 1, 2, 1};
+   const size_t lldpXdot3LocPortTable_oid_len =
+      OID_LENGTH (lldpXdot3LocPortTable_oid);
+   netsnmp_handler_registration * reg;
+   netsnmp_iterator_info * iinfo;
+   netsnmp_table_registration_info * table_info;
+
+   reg = netsnmp_create_handler_registration (
+      "lldpXdot3LocPortTable",
+      lldpXdot3LocPortTable_handler,
+      lldpXdot3LocPortTable_oid,
+      lldpXdot3LocPortTable_oid_len,
+      HANDLER_CAN_RONLY);
+
+   reg->my_reg_void = pnet;
+
+   table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
+   netsnmp_table_helper_add_indexes (
+      table_info,
+      ASN_INTEGER, /* index: lldpLocPortNum */
+      0);
+   table_info->min_column = COLUMN_LLDPXDOT3LOCPORTAUTONEGSUPPORTED;
+   table_info->max_column = COLUMN_LLDPXDOT3LOCPORTOPERMAUTYPE;
+
+   iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
+   iinfo->get_first_data_point = lldpXdot3LocPortTable_get_first_data_point;
+   iinfo->get_next_data_point = lldpXdot3LocPortTable_get_next_data_point;
+   iinfo->table_reginfo = table_info;
+
+   iinfo->free_loop_context_at_end = lldpXdot3LocPortTable_loop_free;
+   iinfo->myvoid = pnet;
+
+   netsnmp_register_table_iterator (reg, iinfo);
+}
+
+netsnmp_variable_list * lldpXdot3LocPortTable_get_first_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+
+   iterator = SNMP_MALLOC_TYPEDEF (pf_port_iterator_t);
+   pf_snmp_init_port_iterator (pnet, iterator);
+   *my_loop_context = iterator;
+
+   return lldpXdot3LocPortTable_get_next_data_point (
+      my_loop_context,
+      my_data_context,
+      put_index_data,
+      mydata);
+}
+
+netsnmp_variable_list * lldpXdot3LocPortTable_get_next_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   netsnmp_variable_list * idx = put_index_data;
+   pf_port_iterator_t * iterator;
+   int port;
+
+   iterator = (pf_port_iterator_t *)*my_loop_context;
+   port = pf_snmp_get_next_port (iterator);
+   if (port == 0)
+   {
+      return NULL;
+   }
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+
+   *my_data_context = (void *)(uintptr_t)port;
+   return put_index_data;
+}
+
+/** handles requests for the lldpXdot3LocPortTable table */
+int lldpXdot3LocPortTable_handler (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   netsnmp_request_info * request;
+   netsnmp_table_request_info * table_info;
+   pnet_t * pnet = reginfo->my_reg_void;
+   void * my_data_context;
+   pf_snmp_link_status_t link_status;
+   int port;
+
+   switch (reqinfo->mode)
+   {
+      /*
+       * Read-support (also covers GetNext requests)
+       */
+   case MODE_GET:
+      for (request = requests; request; request = request->next)
+      {
+         my_data_context = netsnmp_extract_iterator_context (request);
+         table_info = netsnmp_extract_table_info (request);
+
+         LOG_DEBUG (
+            PF_SNMP_LOG,
+            "lldpXdot3LocPortTable(%d): GET. Column number: %u\n",
+            __LINE__,
+            table_info->colnum);
+
+         switch (table_info->colnum)
+         {
+         case COLUMN_LLDPXDOT3LOCPORTAUTONEGSUPPORTED:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            pf_snmp_get_link_status (pnet, port, &link_status);
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               link_status.auto_neg_supported);
+            break;
+         case COLUMN_LLDPXDOT3LOCPORTAUTONEGENABLED:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            pf_snmp_get_link_status (pnet, port, &link_status);
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               link_status.auto_neg_enabled);
+            break;
+         case COLUMN_LLDPXDOT3LOCPORTAUTONEGADVERTISEDCAP:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            pf_snmp_get_link_status (pnet, port, &link_status);
+            snmp_set_var_typed_value (
+               request->requestvb,
+               ASN_OCTET_STR,
+               &link_status.auto_neg_advertised_cap,
+               sizeof (link_status.auto_neg_advertised_cap));
+            break;
+         case COLUMN_LLDPXDOT3LOCPORTOPERMAUTYPE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            pf_snmp_get_link_status (pnet, port, &link_status);
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               link_status.oper_mau_type);
+            break;
+         default:
+            netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
+            break;
+         }
+      }
+      break;
+   default:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpXdot3LocPortTable(%d): Unknown mode: %u\n",
+         __LINE__,
+         reqinfo->mode);
+      break;
+   }
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/lldpXdot3LocPortTable.h b/src/ports/nuttx/mib/lldpXdot3LocPortTable.h
new file mode 100644
index 0000000..0690876
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpXdot3LocPortTable.h
@@ -0,0 +1,37 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+#ifndef LLDPXDOT3LOCPORTTABLE_H
+#define LLDPXDOT3LOCPORTTABLE_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_lldpXdot3LocPortTable (pnet_t * pnet);
+void initialize_table_lldpXdot3LocPortTable (pnet_t * pnet);
+Netsnmp_Node_Handler lldpXdot3LocPortTable_handler;
+Netsnmp_First_Data_Point lldpXdot3LocPortTable_get_first_data_point;
+Netsnmp_Next_Data_Point lldpXdot3LocPortTable_get_next_data_point;
+
+/* column number definitions for table lldpXdot3LocPortTable */
+#define COLUMN_LLDPXDOT3LOCPORTAUTONEGSUPPORTED     1
+#define COLUMN_LLDPXDOT3LOCPORTAUTONEGENABLED       2
+#define COLUMN_LLDPXDOT3LOCPORTAUTONEGADVERTISEDCAP 3
+#define COLUMN_LLDPXDOT3LOCPORTOPERMAUTYPE          4
+#endif /* LLDPXDOT3LOCPORTTABLE_H */
diff --git a/src/ports/nuttx/mib/lldpXdot3RemPortTable.c b/src/ports/nuttx/mib/lldpXdot3RemPortTable.c
new file mode 100644
index 0000000..5d71314
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpXdot3RemPortTable.c
@@ -0,0 +1,277 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "lldpXdot3RemPortTable.h"
+
+/** Initializes the lldpXdot3RemPortTable module */
+void init_lldpXdot3RemPortTable (pnet_t * pnet)
+{
+   /* here we initialize all the tables we're planning on supporting */
+   initialize_table_lldpXdot3RemPortTable (pnet);
+}
+
+static void lldpXdot3RemPortTable_loop_free (
+   void * loopctx,
+   netsnmp_iterator_info * iinfo)
+{
+   SNMP_FREE (loopctx);
+}
+
+/** Initialize the lldpXdot3RemPortTable table by defining its contents and how
+ * it's structured */
+void initialize_table_lldpXdot3RemPortTable (pnet_t * pnet)
+{
+   const oid lldpXdot3RemPortTable_oid[] =
+      {1, 0, 8802, 1, 1, 2, 1, 5, 4623, 1, 3, 1};
+   const size_t lldpXdot3RemPortTable_oid_len =
+      OID_LENGTH (lldpXdot3RemPortTable_oid);
+   netsnmp_handler_registration * reg;
+   netsnmp_iterator_info * iinfo;
+   netsnmp_table_registration_info * table_info;
+
+   reg = netsnmp_create_handler_registration (
+      "lldpXdot3RemPortTable",
+      lldpXdot3RemPortTable_handler,
+      lldpXdot3RemPortTable_oid,
+      lldpXdot3RemPortTable_oid_len,
+      HANDLER_CAN_RONLY);
+
+   reg->my_reg_void = pnet;
+
+   table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
+   netsnmp_table_helper_add_indexes (
+      table_info,
+      ASN_TIMETICKS, /* index: lldpRemTimeMark */
+      ASN_INTEGER,   /* index: lldpRemLocalPortNum */
+      ASN_INTEGER,   /* index: lldpRemIndex */
+      0);
+   table_info->min_column = COLUMN_LLDPXDOT3REMPORTAUTONEGSUPPORTED;
+   table_info->max_column = COLUMN_LLDPXDOT3REMPORTOPERMAUTYPE;
+
+   iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
+   iinfo->get_first_data_point = lldpXdot3RemPortTable_get_first_data_point;
+   iinfo->get_next_data_point = lldpXdot3RemPortTable_get_next_data_point;
+   iinfo->table_reginfo = table_info;
+
+   iinfo->free_loop_context_at_end = lldpXdot3RemPortTable_loop_free;
+   iinfo->myvoid = pnet;
+
+   netsnmp_register_table_iterator (reg, iinfo);
+}
+
+netsnmp_variable_list * lldpXdot3RemPortTable_get_first_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+
+   iterator = SNMP_MALLOC_TYPEDEF (pf_port_iterator_t);
+   pf_snmp_init_port_iterator (pnet, iterator);
+   *my_loop_context = iterator;
+
+   return lldpXdot3RemPortTable_get_next_data_point (
+      my_loop_context,
+      my_data_context,
+      put_index_data,
+      mydata);
+}
+
+netsnmp_variable_list * lldpXdot3RemPortTable_get_next_data_point (
+   void ** my_loop_context,
+   void ** my_data_context,
+   netsnmp_variable_list * put_index_data,
+   netsnmp_iterator_info * mydata)
+{
+   netsnmp_variable_list * idx = put_index_data;
+   pnet_t * pnet = (pnet_t *)mydata->myvoid;
+   pf_port_iterator_t * iterator;
+   int port;
+   uint32_t timestamp;
+   int error;
+
+   iterator = (pf_port_iterator_t *)*my_loop_context;
+
+   do
+   {
+      port = pf_snmp_get_next_port (iterator);
+      if (port == 0)
+      {
+         return NULL;
+      }
+
+      error = pf_snmp_get_peer_timestamp (pnet, port, &timestamp);
+   } while (error);
+
+   snmp_set_var_typed_integer (idx, ASN_TIMETICKS, timestamp);
+   idx = idx->next_variable;
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+   idx = idx->next_variable;
+
+   snmp_set_var_typed_integer (idx, ASN_INTEGER, port);
+
+   *my_data_context = (void *)(uintptr_t)port;
+   return put_index_data;
+}
+
+/** handles requests for the lldpXdot3RemPortTable table */
+int lldpXdot3RemPortTable_handler (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   netsnmp_request_info * request;
+   netsnmp_table_request_info * table_info;
+   pnet_t * pnet = reginfo->my_reg_void;
+   void * my_data_context;
+   pf_snmp_link_status_t link_status;
+   int port;
+   int error;
+
+   switch (reqinfo->mode)
+   {
+      /*
+       * Read-support (also covers GetNext requests)
+       */
+   case MODE_GET:
+      for (request = requests; request; request = request->next)
+      {
+         my_data_context = netsnmp_extract_iterator_context (request);
+         table_info = netsnmp_extract_table_info (request);
+
+         LOG_DEBUG (
+            PF_SNMP_LOG,
+            "lldpXdot3RemPortTable(%d): GET. Column number: %u\n",
+            __LINE__,
+            table_info->colnum);
+
+         switch (table_info->colnum)
+         {
+         case COLUMN_LLDPXDOT3REMPORTAUTONEGSUPPORTED:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_link_status (pnet, port, &link_status);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               link_status.auto_neg_supported);
+            break;
+         case COLUMN_LLDPXDOT3REMPORTAUTONEGENABLED:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_link_status (pnet, port, &link_status);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               link_status.auto_neg_enabled);
+            break;
+         case COLUMN_LLDPXDOT3REMPORTAUTONEGADVERTISEDCAP:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_link_status (pnet, port, &link_status);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_value (
+               request->requestvb,
+               ASN_OCTET_STR,
+               &link_status.auto_neg_advertised_cap,
+               sizeof (link_status.auto_neg_advertised_cap));
+            break;
+         case COLUMN_LLDPXDOT3REMPORTOPERMAUTYPE:
+            if (my_data_context == NULL)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            port = (int)(uintptr_t)my_data_context;
+            error = pf_snmp_get_peer_link_status (pnet, port, &link_status);
+            if (error)
+            {
+               netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
+               continue;
+            }
+
+            snmp_set_var_typed_integer (
+               request->requestvb,
+               ASN_INTEGER,
+               link_status.oper_mau_type);
+            break;
+         default:
+            netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
+            break;
+         }
+      }
+      break;
+   default:
+      LOG_DEBUG (
+         PF_SNMP_LOG,
+         "lldpXdot3RemPortTable(%d): Unknown mode: %u\n",
+         __LINE__,
+         reqinfo->mode);
+      break;
+   }
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/lldpXdot3RemPortTable.h b/src/ports/nuttx/mib/lldpXdot3RemPortTable.h
new file mode 100644
index 0000000..cad2ef1
--- /dev/null
+++ b/src/ports/nuttx/mib/lldpXdot3RemPortTable.h
@@ -0,0 +1,37 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
+ */
+#ifndef LLDPXDOT3REMPORTTABLE_H
+#define LLDPXDOT3REMPORTTABLE_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_lldpXdot3RemPortTable (pnet_t * pnet);
+void initialize_table_lldpXdot3RemPortTable (pnet_t * pnet);
+Netsnmp_Node_Handler lldpXdot3RemPortTable_handler;
+Netsnmp_First_Data_Point lldpXdot3RemPortTable_get_first_data_point;
+Netsnmp_Next_Data_Point lldpXdot3RemPortTable_get_next_data_point;
+
+/* column number definitions for table lldpXdot3RemPortTable */
+#define COLUMN_LLDPXDOT3REMPORTAUTONEGSUPPORTED     1
+#define COLUMN_LLDPXDOT3REMPORTAUTONEGENABLED       2
+#define COLUMN_LLDPXDOT3REMPORTAUTONEGADVERTISEDCAP 3
+#define COLUMN_LLDPXDOT3REMPORTOPERMAUTYPE          4
+#endif /* LLDPXDOT3REMPORTTABLE_H */
diff --git a/src/ports/nuttx/mib/system_mib.c b/src/ports/nuttx/mib/system_mib.c
new file mode 100644
index 0000000..5437e4b
--- /dev/null
+++ b/src/ports/nuttx/mib/system_mib.c
@@ -0,0 +1,619 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.scalar.conf
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#undef LOG_DEBUG
+#undef LOG_WARNING
+#undef LOG_INFO
+#undef LOG_ERROR
+#undef LOG_FATAL
+
+#include "system_mib.h"
+
+#include <sys/sysinfo.h>
+
+/** Initializes the system_mib module */
+void init_system_mib (pnet_t * pnet)
+{
+   const oid sysDescr_oid[] = {1, 3, 6, 1, 2, 1, 1, 1};
+   const oid sysObjectID_oid[] = {1, 3, 6, 1, 2, 1, 1, 2};
+   const oid sysUpTime_oid[] = {1, 3, 6, 1, 2, 1, 1, 3};
+   const oid sysContact_oid[] = {1, 3, 6, 1, 2, 1, 1, 4};
+   const oid sysName_oid[] = {1, 3, 6, 1, 2, 1, 1, 5};
+   const oid sysLocation_oid[] = {1, 3, 6, 1, 2, 1, 1, 6};
+   const oid sysServices_oid[] = {1, 3, 6, 1, 2, 1, 1, 7};
+   netsnmp_handler_registration * reg;
+
+   netsnmp_register_scalar (
+      reg = netsnmp_create_handler_registration (
+         "sysDescr",
+         handle_sysDescr,
+         sysDescr_oid,
+         OID_LENGTH (sysDescr_oid),
+         HANDLER_CAN_RONLY));
+
+   reg->my_reg_void = pnet;
+
+   netsnmp_register_scalar (
+      reg = netsnmp_create_handler_registration (
+         "sysObjectID",
+         handle_sysObjectID,
+         sysObjectID_oid,
+         OID_LENGTH (sysObjectID_oid),
+         HANDLER_CAN_RONLY));
+
+   reg->my_reg_void = pnet;
+
+   netsnmp_register_scalar (
+      reg = netsnmp_create_handler_registration (
+         "sysUpTime",
+         handle_sysUpTime,
+         sysUpTime_oid,
+         OID_LENGTH (sysUpTime_oid),
+         HANDLER_CAN_RONLY));
+
+   reg->my_reg_void = pnet;
+
+   netsnmp_register_scalar (
+      reg = netsnmp_create_handler_registration (
+         "sysContact",
+         handle_sysContact,
+         sysContact_oid,
+         OID_LENGTH (sysContact_oid),
+         HANDLER_CAN_RWRITE));
+
+   reg->my_reg_void = pnet;
+
+   netsnmp_register_scalar (
+      reg = netsnmp_create_handler_registration (
+         "sysName",
+         handle_sysName,
+         sysName_oid,
+         OID_LENGTH (sysName_oid),
+         HANDLER_CAN_RWRITE));
+
+   reg->my_reg_void = pnet;
+
+   netsnmp_register_scalar (
+      reg = netsnmp_create_handler_registration (
+         "sysLocation",
+         handle_sysLocation,
+         sysLocation_oid,
+         OID_LENGTH (sysLocation_oid),
+         HANDLER_CAN_RWRITE));
+
+   reg->my_reg_void = pnet;
+
+   netsnmp_register_scalar (
+      reg = netsnmp_create_handler_registration (
+         "sysServices",
+         handle_sysServices,
+         sysServices_oid,
+         OID_LENGTH (sysServices_oid),
+         HANDLER_CAN_RONLY));
+
+   reg->my_reg_void = pnet;
+}
+
+int handle_sysDescr (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   pnet_t * pnet = reginfo->my_reg_void;
+   pf_snmp_system_description_t sysdescription;
+
+   /* We are never called for a GETNEXT if it's registered as a
+      "instance", as it's "magically" handled for us.  */
+
+   /* a instance handler also only hands us one request at a time, so
+      we don't need to loop over a list of requests; we'll only get one. */
+
+   pf_snmp_get_system_description (pnet, &sysdescription);
+
+   switch (reqinfo->mode)
+   {
+
+   case MODE_GET:
+      LOG_DEBUG (PF_SNMP_LOG, "system_mib(%d): GET sysDescr.\n", __LINE__);
+      snmp_set_var_typed_value (
+         requests->requestvb,
+         ASN_OCTET_STR,
+         sysdescription.string,
+         strlen (sysdescription.string));
+      break;
+
+   default:
+      /* we should never get here, so this is a really bad error */
+      LOG_ERROR (
+         PF_SNMP_LOG,
+         "system_mib(%d): unknown mode (%d)\n",
+         __LINE__,
+         reqinfo->mode);
+      return SNMP_ERR_GENERR;
+   }
+
+   return SNMP_ERR_NOERROR;
+}
+int handle_sysObjectID (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   const oid sysoid[] = {1, 3, 6, 1, 4, 1, 24686};
+
+   /* We are never called for a GETNEXT if it's registered as a
+      "instance", as it's "magically" handled for us.  */
+
+   /* a instance handler also only hands us one request at a time, so
+      we don't need to loop over a list of requests; we'll only get one. */
+
+   switch (reqinfo->mode)
+   {
+
+   case MODE_GET:
+      LOG_DEBUG (PF_SNMP_LOG, "system_mib(%d): GET sysObjectID.\n", __LINE__);
+      snmp_set_var_typed_value (
+         requests->requestvb,
+         ASN_OBJECT_ID,
+         sysoid,
+         OID_LENGTH (sysoid) * sizeof (oid));
+      break;
+
+   default:
+      /* we should never get here, so this is a really bad error */
+      LOG_ERROR (
+         PF_SNMP_LOG,
+         "system_mib(%d): unknown mode (%d)\n",
+         __LINE__,
+         reqinfo->mode);
+      return SNMP_ERR_GENERR;
+   }
+
+   return SNMP_ERR_NOERROR;
+}
+
+int handle_sysUpTime (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   struct sysinfo systeminfo; /* Field .uptime contains uptime in seconds */
+   uint32_t uptime_10ms;
+
+   /* We are never called for a GETNEXT if it's registered as a
+      "instance", as it's "magically" handled for us.  */
+
+   /* a instance handler also only hands us one request at a time, so
+      we don't need to loop over a list of requests; we'll only get one. */
+
+   switch (reqinfo->mode)
+   {
+   case MODE_GET:
+      LOG_DEBUG (PF_SNMP_LOG, "system_mib(%d): GET sysUpTime.\n", __LINE__);
+      if (sysinfo (&systeminfo) == 0)
+      {
+         uptime_10ms = systeminfo.uptime * 100;
+      }
+      else
+      {
+         uptime_10ms = 0;
+      }
+
+      snmp_set_var_typed_integer (
+         requests->requestvb,
+         ASN_TIMETICKS,
+         uptime_10ms);
+      break;
+
+   default:
+      /* we should never get here, so this is a really bad error */
+      LOG_ERROR (
+         PF_SNMP_LOG,
+         "system_mib(%d): unknown mode (%d)\n",
+         __LINE__,
+         reqinfo->mode);
+      return SNMP_ERR_GENERR;
+   }
+
+   return SNMP_ERR_NOERROR;
+}
+
+int handle_sysContact (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   int ret;
+   pnet_t * pnet = reginfo->my_reg_void;
+   pf_snmp_system_contact_t syscontact;
+   static pf_snmp_system_contact_t * old_syscontact;
+
+   /* We are never called for a GETNEXT if it's registered as a
+      "instance", as it's "magically" handled for us.  */
+
+   /* a instance handler also only hands us one request at a time, so
+      we don't need to loop over a list of requests; we'll only get one. */
+
+   LOG_DEBUG (
+      PF_SNMP_LOG,
+      "system_mib(%d): Handle sysContact. Mode: %d\n",
+      __LINE__,
+      reqinfo->mode);
+
+   switch (reqinfo->mode)
+   {
+
+   case MODE_GET:
+      pf_snmp_get_system_contact (pnet, &syscontact);
+      snmp_set_var_typed_value (
+         requests->requestvb,
+         ASN_OCTET_STR,
+         syscontact.string,
+         strlen (syscontact.string));
+      break;
+
+   /*
+    * SET REQUEST
+    *
+    * multiple states in the transaction.  See:
+    * http://www.net-snmp.org/tutorial/tutorial-5/toolkit/mib_module/set-actions.jpg
+    */
+   case MODE_SET_RESERVE1:
+      old_syscontact = NULL;
+      ret = netsnmp_check_vb_type_and_max_size (
+         requests->requestvb,
+         ASN_OCTET_STR,
+         sizeof (syscontact.string) - 1);
+      if (ret != SNMP_ERR_NOERROR)
+      {
+         netsnmp_set_request_error (reqinfo, requests, ret);
+      }
+      break;
+
+   case MODE_SET_RESERVE2:
+      old_syscontact = SNMP_MALLOC_TYPEDEF (pf_snmp_system_contact_t);
+      if (old_syscontact == NULL)
+      {
+         netsnmp_set_request_error (
+            reqinfo,
+            requests,
+            SNMP_ERR_RESOURCEUNAVAILABLE);
+      }
+      else
+      {
+         pf_snmp_get_system_contact (pnet, old_syscontact);
+      }
+      break;
+
+   case MODE_SET_FREE:
+      if (old_syscontact != NULL)
+      {
+         SNMP_FREE (old_syscontact);
+      }
+      break;
+
+   case MODE_SET_ACTION:
+      memcpy (
+         syscontact.string,
+         requests->requestvb->val.string,
+         requests->requestvb->val_len);
+      syscontact.string[requests->requestvb->val_len] = '\0';
+      ret = pf_snmp_set_system_contact (pnet, &syscontact);
+      if (ret)
+      {
+         netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_GENERR);
+      }
+      break;
+
+   case MODE_SET_COMMIT:
+      SNMP_FREE (old_syscontact);
+      break;
+
+   case MODE_SET_UNDO:
+      ret = pf_snmp_set_system_contact (pnet, old_syscontact);
+      if (ret)
+      {
+         netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_UNDOFAILED);
+      }
+      SNMP_FREE (old_syscontact);
+      break;
+
+   default:
+      /* we should never get here, so this is a really bad error */
+      LOG_ERROR (
+         PF_SNMP_LOG,
+         "system_mib(%d): unknown mode (%d)\n",
+         __LINE__,
+         reqinfo->mode);
+      return SNMP_ERR_GENERR;
+   }
+
+   return SNMP_ERR_NOERROR;
+}
+
+int handle_sysName (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   int ret;
+   pnet_t * pnet = reginfo->my_reg_void;
+   pf_snmp_system_name_t sysname;
+   static pf_snmp_system_name_t * old_sysname;
+
+   /* We are never called for a GETNEXT if it's registered as a
+      "instance", as it's "magically" handled for us.  */
+
+   /* a instance handler also only hands us one request at a time, so
+      we don't need to loop over a list of requests; we'll only get one. */
+
+   LOG_DEBUG (
+      PF_SNMP_LOG,
+      "system_mib(%d): Handle sysName. Mode: %d\n",
+      __LINE__,
+      reqinfo->mode);
+
+   switch (reqinfo->mode)
+   {
+
+   case MODE_GET:
+      pf_snmp_get_system_name (pnet, &sysname);
+      snmp_set_var_typed_value (
+         requests->requestvb,
+         ASN_OCTET_STR,
+         sysname.string,
+         strlen (sysname.string));
+      break;
+
+   /*
+    * SET REQUEST
+    *
+    * multiple states in the transaction.  See:
+    * http://www.net-snmp.org/tutorial/tutorial-5/toolkit/mib_module/set-actions.jpg
+    */
+   case MODE_SET_RESERVE1:
+      old_sysname = NULL;
+      ret = netsnmp_check_vb_type_and_max_size (
+         requests->requestvb,
+         ASN_OCTET_STR,
+         sizeof (sysname.string) - 1);
+      if (ret != SNMP_ERR_NOERROR)
+      {
+         netsnmp_set_request_error (reqinfo, requests, ret);
+      }
+      break;
+
+   case MODE_SET_RESERVE2:
+      old_sysname = SNMP_MALLOC_TYPEDEF (pf_snmp_system_name_t);
+      if (old_sysname == NULL)
+      {
+         netsnmp_set_request_error (
+            reqinfo,
+            requests,
+            SNMP_ERR_RESOURCEUNAVAILABLE);
+      }
+      else
+      {
+         pf_snmp_get_system_name (pnet, old_sysname);
+      }
+      break;
+
+   case MODE_SET_FREE:
+      if (old_sysname != NULL)
+      {
+         SNMP_FREE (old_sysname);
+      }
+      break;
+
+   case MODE_SET_ACTION:
+      memcpy (
+         sysname.string,
+         requests->requestvb->val.string,
+         requests->requestvb->val_len);
+      sysname.string[requests->requestvb->val_len] = '\0';
+      ret = pf_snmp_set_system_name (pnet, &sysname);
+      if (ret)
+      {
+         netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_GENERR);
+      }
+      break;
+
+   case MODE_SET_COMMIT:
+      SNMP_FREE (old_sysname);
+      break;
+
+   case MODE_SET_UNDO:
+      ret = pf_snmp_set_system_name (pnet, old_sysname);
+      if (ret)
+      {
+         netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_UNDOFAILED);
+      }
+      SNMP_FREE (old_sysname);
+      break;
+
+   default:
+      /* we should never get here, so this is a really bad error */
+      LOG_ERROR (
+         PF_SNMP_LOG,
+         "system_mib(%d): unknown mode (%d)\n",
+         __LINE__,
+         reqinfo->mode);
+      return SNMP_ERR_GENERR;
+   }
+
+   return SNMP_ERR_NOERROR;
+}
+
+int handle_sysLocation (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   int ret;
+   pnet_t * pnet = reginfo->my_reg_void;
+   pf_snmp_system_location_t syslocation;
+   static pf_snmp_system_location_t * old_syslocation;
+
+   /* We are never called for a GETNEXT if it's registered as a
+      "instance", as it's "magically" handled for us.  */
+
+   /* a instance handler also only hands us one request at a time, so
+      we don't need to loop over a list of requests; we'll only get one. */
+
+   LOG_DEBUG (
+      PF_SNMP_LOG,
+      "system_mib(%d): Handle sysLocation. Mode: %d\n",
+      __LINE__,
+      reqinfo->mode);
+
+   switch (reqinfo->mode)
+   {
+
+   case MODE_GET:
+      pf_snmp_get_system_location (pnet, &syslocation);
+      snmp_set_var_typed_value (
+         requests->requestvb,
+         ASN_OCTET_STR,
+         syslocation.string,
+         strlen (syslocation.string));
+      break;
+
+   /*
+    * SET REQUEST
+    *
+    * multiple states in the transaction.  See:
+    * http://www.net-snmp.org/tutorial/tutorial-5/toolkit/mib_module/set-actions.jpg
+    */
+   case MODE_SET_RESERVE1:
+      old_syslocation = NULL;
+      ret = netsnmp_check_vb_type_and_max_size (
+         requests->requestvb,
+         ASN_OCTET_STR,
+         sizeof (syslocation.string) - 1);
+      if (ret != SNMP_ERR_NOERROR)
+      {
+         netsnmp_set_request_error (reqinfo, requests, ret);
+      }
+      break;
+
+   case MODE_SET_RESERVE2:
+      old_syslocation = SNMP_MALLOC_TYPEDEF (pf_snmp_system_location_t);
+      if (old_syslocation == NULL)
+      {
+         netsnmp_set_request_error (
+            reqinfo,
+            requests,
+            SNMP_ERR_RESOURCEUNAVAILABLE);
+      }
+      else
+      {
+         pf_snmp_get_system_location (pnet, old_syslocation);
+      }
+      break;
+
+   case MODE_SET_FREE:
+      if (old_syslocation != NULL)
+      {
+         SNMP_FREE (old_syslocation);
+      }
+      break;
+
+   case MODE_SET_ACTION:
+      memcpy (
+         syslocation.string,
+         requests->requestvb->val.string,
+         requests->requestvb->val_len);
+      syslocation.string[requests->requestvb->val_len] = '\0';
+      ret = pf_snmp_set_system_location (pnet, &syslocation);
+      if (ret)
+      {
+         netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_GENERR);
+      }
+      break;
+
+   case MODE_SET_COMMIT:
+      SNMP_FREE (old_syslocation);
+      break;
+
+   case MODE_SET_UNDO:
+      ret = pf_snmp_set_system_location (pnet, old_syslocation);
+      if (ret)
+      {
+         netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_UNDOFAILED);
+      }
+      SNMP_FREE (old_syslocation);
+      break;
+
+   default:
+      /* we should never get here, so this is a really bad error */
+      LOG_ERROR (
+         PF_SNMP_LOG,
+         "system_mib(%d): unknown mode (%d)\n",
+         __LINE__,
+         reqinfo->mode);
+      return SNMP_ERR_GENERR;
+   }
+
+   return SNMP_ERR_NOERROR;
+}
+
+int handle_sysServices (
+   netsnmp_mib_handler * handler,
+   netsnmp_handler_registration * reginfo,
+   netsnmp_agent_request_info * reqinfo,
+   netsnmp_request_info * requests)
+{
+   /* We are never called for a GETNEXT if it's registered as a
+      "instance", as it's "magically" handled for us.  */
+
+   /* a instance handler also only hands us one request at a time, so
+      we don't need to loop over a list of requests; we'll only get one. */
+
+   switch (reqinfo->mode)
+   {
+
+   case MODE_GET:
+      LOG_DEBUG (PF_SNMP_LOG, "system_mib(%d): GET sysServices\n", __LINE__);
+      /* Supported services. Should be 78 for Profinet. See IETF RFC 3418. */
+      snmp_set_var_typed_integer (requests->requestvb, ASN_INTEGER, 78);
+      break;
+
+   default:
+      /* we should never get here, so this is a really bad error */
+      LOG_ERROR (
+         PF_SNMP_LOG,
+         "system_mib(%d): unknown mode (%d)\n",
+         __LINE__,
+         reqinfo->mode);
+      return SNMP_ERR_GENERR;
+   }
+
+   return SNMP_ERR_NOERROR;
+}
diff --git a/src/ports/nuttx/mib/system_mib.h b/src/ports/nuttx/mib/system_mib.h
new file mode 100644
index 0000000..22d44ac
--- /dev/null
+++ b/src/ports/nuttx/mib/system_mib.h
@@ -0,0 +1,35 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/*
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.scalar.conf
+ */
+#ifndef SYSTEM_MIB_H
+#define SYSTEM_MIB_H
+
+#include "pf_includes.h"
+
+/* function declarations */
+void init_system_mib (pnet_t * pnet);
+Netsnmp_Node_Handler handle_sysDescr;
+Netsnmp_Node_Handler handle_sysObjectID;
+Netsnmp_Node_Handler handle_sysUpTime;
+Netsnmp_Node_Handler handle_sysContact;
+Netsnmp_Node_Handler handle_sysName;
+Netsnmp_Node_Handler handle_sysLocation;
+Netsnmp_Node_Handler handle_sysServices;
+
+#endif /* SYSTEM_MIB_H */
diff --git a/src/ports/nuttx/osal/osal.c b/src/ports/nuttx/osal/osal.c
new file mode 100644
index 0000000..9eb126a
--- /dev/null
+++ b/src/ports/nuttx/osal/osal.c
@@ -0,0 +1,606 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2017 rt-labs AB, Sweden.
+ *
+ * This software is licensed under the terms of the BSD 3-clause
+ * license. See the file LICENSE distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#define _GNU_SOURCE /* For pthread_setname_mp() */
+
+#include "osal.h"
+/* #include "options.h" */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <signal.h>
+#include <limits.h>
+
+#include <pthread.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <nuttx/sched.h>
+
+/* Priority of timer callback thread (if USE_SCHED_FIFO is set) */
+#define TIMER_PRIO 30
+
+#define USECS_PER_SEC (1 * 1000 * 1000)
+#define NSECS_PER_SEC (1 * 1000 * 1000 * 1000)
+
+void * os_malloc (size_t size)
+{
+   return malloc (size);
+}
+
+void os_free (void * ptr)
+{
+   free (ptr);
+}
+
+os_thread_t * os_thread_create (
+   const char * name,
+   uint32_t priority,
+   size_t stacksize,
+   void (*entry) (void * arg),
+   void * arg)
+{
+   int result;
+   pthread_t * thread;
+   pthread_attr_t attr;
+
+   thread = malloc (sizeof (*thread));
+   if (thread == NULL)
+   {
+      return NULL;
+   }
+
+   pthread_attr_init (&attr);
+   pthread_attr_setstacksize (&attr, PTHREAD_STACK_MIN + stacksize);
+
+#if defined(USE_SCHED_FIFO)
+   CC_STATIC_ASSERT (_POSIX_THREAD_PRIORITY_SCHEDULING > 0);
+   struct sched_param param = {.sched_priority = priority};
+   pthread_attr_setinheritsched (&attr, PTHREAD_EXPLICIT_SCHED);
+   pthread_attr_setschedpolicy (&attr, SCHED_FIFO);
+   pthread_attr_setschedparam (&attr, &param);
+#endif
+
+   result = pthread_create (thread, &attr, (void *)entry, arg);
+   if (result != 0)
+   {
+      free (thread);
+      return NULL;
+   }
+
+   pthread_setname_np (*thread, name);
+   return thread;
+}
+
+os_mutex_t * os_mutex_create (void)
+{
+   int result;
+   pthread_mutex_t * mutex;
+   pthread_mutexattr_t mattr;
+
+   mutex = malloc (sizeof (*mutex));
+   if (mutex == NULL)
+   {
+      return NULL;
+   }
+
+   CC_STATIC_ASSERT (_SC_THREAD_PRIO_INHERIT > 0);
+   pthread_mutexattr_init (&mattr);
+   pthread_mutexattr_setprotocol (&mattr, PTHREAD_PRIO_INHERIT);
+   pthread_mutexattr_settype (&mattr, PTHREAD_MUTEX_RECURSIVE);
+
+   result = pthread_mutex_init (mutex, &mattr);
+   if (result != 0)
+   {
+      free (mutex);
+      return NULL;
+   }
+
+   return mutex;
+}
+
+void os_mutex_lock (os_mutex_t * _mutex)
+{
+   pthread_mutex_t * mutex = _mutex;
+   pthread_mutex_lock (mutex);
+}
+
+void os_mutex_unlock (os_mutex_t * _mutex)
+{
+   pthread_mutex_t * mutex = _mutex;
+   pthread_mutex_unlock (mutex);
+}
+
+void os_mutex_destroy (os_mutex_t * _mutex)
+{
+   pthread_mutex_t * mutex = _mutex;
+   pthread_mutex_destroy (mutex);
+   free (mutex);
+}
+
+os_sem_t * os_sem_create (size_t count)
+{
+   os_sem_t * sem;
+   pthread_mutexattr_t mattr;
+   pthread_condattr_t cattr;
+
+   sem = malloc (sizeof (*sem));
+   if (sem == NULL)
+   {
+      return NULL;
+   }
+
+   pthread_condattr_init (&cattr);
+   pthread_condattr_setclock (&cattr, CLOCK_MONOTONIC);
+   pthread_cond_init (&sem->cond, &cattr);
+   pthread_mutexattr_init (&mattr);
+   pthread_mutexattr_setprotocol (&mattr, PTHREAD_PRIO_INHERIT);
+   pthread_mutex_init (&sem->mutex, &mattr);
+   sem->count = count;
+
+   return sem;
+}
+
+bool os_sem_wait (os_sem_t * sem, uint32_t time)
+{
+   struct timespec ts;
+   int error     = 0;
+   uint64_t nsec = (uint64_t)time * 1000 * 1000;
+
+   clock_gettime (CLOCK_MONOTONIC, &ts);
+   nsec += ts.tv_nsec;
+   if (nsec > NSECS_PER_SEC)
+   {
+      ts.tv_sec += nsec / NSECS_PER_SEC;
+      nsec %= NSECS_PER_SEC;
+   }
+   ts.tv_nsec = nsec;
+
+   pthread_mutex_lock (&sem->mutex);
+   while (sem->count == 0)
+   {
+      if (time != OS_WAIT_FOREVER)
+      {
+         error = pthread_cond_timedwait (&sem->cond, &sem->mutex, &ts);
+         assert (error != EINVAL);
+         if (error)
+         {
+            goto timeout;
+         }
+      }
+      else
+      {
+         error = pthread_cond_wait (&sem->cond, &sem->mutex);
+         assert (error != EINVAL);
+      }
+   }
+
+   sem->count--;
+
+timeout:
+   pthread_mutex_unlock (&sem->mutex);
+   return (error != 0);
+}
+
+void os_sem_signal (os_sem_t * sem)
+{
+   pthread_mutex_lock (&sem->mutex);
+   sem->count++;
+   pthread_mutex_unlock (&sem->mutex);
+   pthread_cond_signal (&sem->cond);
+}
+
+void os_sem_destroy (os_sem_t * sem)
+{
+   pthread_cond_destroy (&sem->cond);
+   pthread_mutex_destroy (&sem->mutex);
+   free (sem);
+}
+
+void os_usleep (uint32_t usec)
+{
+   struct timespec ts;
+   struct timespec remain;
+
+   ts.tv_sec  = usec / USECS_PER_SEC;
+   ts.tv_nsec = (usec % USECS_PER_SEC) * 1000;
+   while (clock_nanosleep (CLOCK_MONOTONIC, 0, &ts, &remain) != 0)
+   {
+      ts = remain;
+   }
+}
+
+uint32_t os_get_current_time_us (void)
+{
+   struct timespec ts;
+
+   clock_gettime (CLOCK_MONOTONIC, &ts);
+   return ts.tv_sec * 1000 * 1000 + ts.tv_nsec / 1000;
+}
+
+os_tick_t os_tick_current (void)
+{
+   struct timespec ts;
+   os_tick_t       tick;
+
+   clock_gettime (CLOCK_MONOTONIC, &ts);
+   tick = ts.tv_sec;
+   tick *= NSECS_PER_SEC;
+   tick += ts.tv_nsec;
+   return tick;
+}
+
+os_tick_t os_tick_from_us (uint32_t us)
+{
+   return (os_tick_t)us * 1000;
+}
+
+void os_tick_sleep (os_tick_t tick)
+{
+   struct timespec ts;
+   struct timespec remain;
+
+   ts.tv_sec  = tick / NSECS_PER_SEC;
+   ts.tv_nsec = tick % NSECS_PER_SEC;
+   while (clock_nanosleep (CLOCK_MONOTONIC, 0, &ts, &remain) != 0)
+   {
+      ts = remain;
+   }
+}
+
+os_event_t * os_event_create (void)
+{
+   os_event_t * event;
+   pthread_mutexattr_t mattr;
+   pthread_condattr_t cattr;
+
+   event = (os_event_t *)malloc (sizeof (*event));
+   if (event == NULL)
+   {
+      return NULL;
+   }
+
+   pthread_condattr_init (&cattr);
+   pthread_condattr_setclock (&cattr, CLOCK_MONOTONIC);
+   pthread_cond_init (&event->cond, &cattr);
+   pthread_mutexattr_init (&mattr);
+   pthread_mutexattr_setprotocol (&mattr, PTHREAD_PRIO_INHERIT);
+   pthread_mutex_init (&event->mutex, &mattr);
+   event->flags = 0;
+
+   return event;
+}
+
+bool os_event_wait (os_event_t * event, uint32_t mask, uint32_t * value, uint32_t time)
+{
+   struct timespec ts;
+   int error     = 0;
+   uint64_t nsec = (uint64_t)time * 1000 * 1000;
+
+   if (time != OS_WAIT_FOREVER)
+   {
+      clock_gettime (CLOCK_MONOTONIC, &ts);
+      nsec += ts.tv_nsec;
+
+      ts.tv_sec += nsec / NSECS_PER_SEC;
+      ts.tv_nsec = nsec % NSECS_PER_SEC;
+   }
+
+   pthread_mutex_lock (&event->mutex);
+
+   while ((event->flags & mask) == 0)
+   {
+      if (time != OS_WAIT_FOREVER)
+      {
+         error = pthread_cond_timedwait (&event->cond, &event->mutex, &ts);
+         assert (error != EINVAL);
+         if (error)
+         {
+            goto timeout;
+         }
+      }
+      else
+      {
+         error = pthread_cond_wait (&event->cond, &event->mutex);
+         assert (error != EINVAL);
+      }
+   }
+
+timeout:
+   *value = event->flags & mask;
+   pthread_mutex_unlock (&event->mutex);
+   return (error != 0);
+}
+
+void os_event_set (os_event_t * event, uint32_t value)
+{
+   pthread_mutex_lock (&event->mutex);
+   event->flags |= value;
+   pthread_mutex_unlock (&event->mutex);
+   pthread_cond_signal (&event->cond);
+}
+
+void os_event_clr (os_event_t * event, uint32_t value)
+{
+   pthread_mutex_lock (&event->mutex);
+   event->flags &= ~value;
+   pthread_mutex_unlock (&event->mutex);
+   pthread_cond_signal (&event->cond);
+}
+
+void os_event_destroy (os_event_t * event)
+{
+   pthread_cond_destroy (&event->cond);
+   pthread_mutex_destroy (&event->mutex);
+   free (event);
+}
+
+os_mbox_t * os_mbox_create (size_t size)
+{
+   os_mbox_t * mbox;
+   pthread_mutexattr_t mattr;
+   pthread_condattr_t cattr;
+
+   mbox = (os_mbox_t *)malloc (sizeof (*mbox) + size * sizeof (void *));
+   if (mbox == NULL)
+   {
+      return NULL;
+   }
+
+   pthread_condattr_init (&cattr);
+   pthread_condattr_setclock (&cattr, CLOCK_MONOTONIC);
+   pthread_cond_init (&mbox->cond, &cattr);
+   pthread_mutexattr_init (&mattr);
+   pthread_mutexattr_setprotocol (&mattr, PTHREAD_PRIO_INHERIT);
+   pthread_mutex_init (&mbox->mutex, &mattr);
+
+   mbox->r     = 0;
+   mbox->w     = 0;
+   mbox->count = 0;
+   mbox->size  = size;
+
+   return mbox;
+}
+
+bool os_mbox_fetch (os_mbox_t * mbox, void ** msg, uint32_t time)
+{
+   struct timespec ts;
+   int error     = 0;
+   uint64_t nsec = (uint64_t)time * 1000 * 1000;
+
+   if (time != OS_WAIT_FOREVER)
+   {
+      clock_gettime (CLOCK_MONOTONIC, &ts);
+      nsec += ts.tv_nsec;
+
+      ts.tv_sec += nsec / NSECS_PER_SEC;
+      ts.tv_nsec = nsec % NSECS_PER_SEC;
+   }
+
+   pthread_mutex_lock (&mbox->mutex);
+
+   while (mbox->count == 0)
+   {
+      if (time != OS_WAIT_FOREVER)
+      {
+         error = pthread_cond_timedwait (&mbox->cond, &mbox->mutex, &ts);
+         assert (error != EINVAL);
+         if (error)
+         {
+            goto timeout;
+         }
+      }
+      else
+      {
+         error = pthread_cond_wait (&mbox->cond, &mbox->mutex);
+         assert (error != EINVAL);
+      }
+   }
+
+   *msg = mbox->msg[mbox->r++];
+   if (mbox->r == mbox->size)
+      mbox->r = 0;
+
+   mbox->count--;
+
+timeout:
+   pthread_mutex_unlock (&mbox->mutex);
+   pthread_cond_signal (&mbox->cond);
+
+   return (error != 0);
+}
+
+bool os_mbox_post (os_mbox_t * mbox, void * msg, uint32_t time)
+{
+   struct timespec ts;
+   int error     = 0;
+   uint64_t nsec = (uint64_t)time * 1000 * 1000;
+
+   if (time != OS_WAIT_FOREVER)
+   {
+      clock_gettime (CLOCK_MONOTONIC, &ts);
+      nsec += ts.tv_nsec;
+
+      ts.tv_sec += nsec / NSECS_PER_SEC;
+      ts.tv_nsec = nsec % NSECS_PER_SEC;
+   }
+
+   pthread_mutex_lock (&mbox->mutex);
+
+   while (mbox->count == mbox->size)
+   {
+      if (time != OS_WAIT_FOREVER)
+      {
+         error = pthread_cond_timedwait (&mbox->cond, &mbox->mutex, &ts);
+         assert (error != EINVAL);
+         if (error)
+         {
+            goto timeout;
+         }
+      }
+      else
+      {
+         error = pthread_cond_wait (&mbox->cond, &mbox->mutex);
+         assert (error != EINVAL);
+      }
+   }
+
+   mbox->msg[mbox->w++] = msg;
+   if (mbox->w == mbox->size)
+      mbox->w = 0;
+
+   mbox->count++;
+
+timeout:
+   pthread_mutex_unlock (&mbox->mutex);
+   pthread_cond_signal (&mbox->cond);
+
+   return (error != 0);
+}
+
+void os_mbox_destroy (os_mbox_t * mbox)
+{
+   pthread_cond_destroy (&mbox->cond);
+   pthread_mutex_destroy (&mbox->mutex);
+   free (mbox);
+}
+
+static void os_timer_thread (void * arg)
+{
+   os_timer_t * timer = arg;
+   sigset_t sigset;
+   siginfo_t si;
+   struct timespec tmo;
+
+   timer->thread_id = (pid_t)gettid();
+
+   /* Add SIGALRM */
+   sigemptyset (&sigset);
+   sigprocmask (SIG_BLOCK, &sigset, NULL);
+   sigaddset (&sigset, SIGALRM);
+
+   tmo.tv_sec  = 0;
+   tmo.tv_nsec = 500 * 1000 * 1000;
+
+   while (!timer->exit)
+   {
+      int sig = sigtimedwait (&sigset, &si, &tmo);
+      if (sig == SIGALRM)
+      {
+         if (timer->fn)
+            timer->fn (timer, timer->arg);
+      }
+   }
+}
+
+os_timer_t * os_timer_create (
+   uint32_t us,
+   void (*fn) (os_timer_t *, void * arg),
+   void * arg,
+   bool oneshot)
+{
+   os_timer_t * timer;
+   struct sigevent sev;
+   sigset_t sigset;
+
+   /* Block SIGALRM in calling thread */
+   sigemptyset (&sigset);
+   sigaddset (&sigset, SIGALRM);
+   sigprocmask (SIG_BLOCK, &sigset, NULL);
+
+   timer = (os_timer_t *)malloc (sizeof (*timer));
+   if (timer == NULL)
+   {
+      return NULL;
+   }
+
+   timer->exit      = false;
+   timer->thread_id = 0;
+   timer->fn        = fn;
+   timer->arg       = arg;
+   timer->us        = us;
+   timer->oneshot   = oneshot;
+
+   /* Create timer thread */
+   timer->thread =
+      os_thread_create ("os_timer", TIMER_PRIO, 1024, os_timer_thread, timer);
+   if (timer->thread == NULL)
+   {
+      free (timer);
+      return NULL;
+   }
+
+   /* Wait until timer thread sets its (kernel) thread id */
+   do
+   {
+      sched_yield();
+   } while (timer->thread_id == 0);
+
+   /* Create timer */
+   sev.sigev_notify            = SIGEV_THREAD_ID;
+   sev.sigev_value.sival_ptr   = timer;
+   sev._sigev_un._tid          = timer->thread_id;
+   sev.sigev_signo             = SIGALRM;
+   sev.sigev_notify_attributes = NULL;
+
+   if (timer_create (CLOCK_MONOTONIC, &sev, &timer->timerid) == -1)
+   {
+      free (timer);
+      return NULL;
+   }
+
+   return timer;
+}
+
+void os_timer_set (os_timer_t * timer, uint32_t us)
+{
+   timer->us = us;
+}
+
+void os_timer_start (os_timer_t * timer)
+{
+   struct itimerspec its;
+
+   /* Start timer */
+   its.it_value.tv_sec     = 0;
+   its.it_value.tv_nsec    = 1000 * timer->us;
+   its.it_interval.tv_sec  = (timer->oneshot) ? 0 : its.it_value.tv_sec;
+   its.it_interval.tv_nsec = (timer->oneshot) ? 0 : its.it_value.tv_nsec;
+   timer_settime (timer->timerid, 0, &its, NULL);
+}
+
+void os_timer_stop (os_timer_t * timer)
+{
+   struct itimerspec its;
+
+   /* Stop timer */
+   its.it_value.tv_sec     = 0;
+   its.it_value.tv_nsec    = 0;
+   its.it_interval.tv_sec  = 0;
+   its.it_interval.tv_nsec = 0;
+   timer_settime (timer->timerid, 0, &its, NULL);
+}
+
+void os_timer_destroy (os_timer_t * timer)
+{
+   timer->exit = true;
+   pthread_join (*timer->thread, NULL);
+   timer_delete (timer->timerid);
+   free (timer);
+}
diff --git a/src/ports/nuttx/osal/osal.h b/src/ports/nuttx/osal/osal.h
new file mode 100644
index 0000000..b136e08
--- /dev/null
+++ b/src/ports/nuttx/osal/osal.h
@@ -0,0 +1,139 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2017 rt-labs AB, Sweden.
+ *
+ * This software is licensed under the terms of the BSD 3-clause
+ * license. See the file LICENSE distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#ifndef OSAL_H
+#define OSAL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+#include "sys/osal_sys.h"
+#include "sys/osal_cc.h"
+
+#ifndef MIN
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+#ifndef MAX
+#define MAX(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef BIT
+#define BIT(n) (1U << (n))
+#endif
+
+#ifndef NELEMENTS
+#define NELEMENTS(a) (sizeof (a) / sizeof ((a)[0]))
+#endif
+
+#ifndef OS_WAIT_FOREVER
+#define OS_WAIT_FOREVER 0xFFFFFFFF
+#endif
+
+#ifndef OS_MAIN
+#define OS_MAIN int main
+#endif
+
+#ifndef OS_MUTEX
+typedef void os_mutex_t;
+#endif
+
+#ifndef OS_SEM
+typedef void os_sem_t;
+#endif
+
+#ifndef OS_THREAD
+typedef void os_thread_t;
+#endif
+
+#ifndef OS_EVENT
+typedef void os_event_t;
+#endif
+
+#ifndef OS_MBOX
+typedef void os_mbox_t;
+#endif
+
+#ifndef OS_TIMER
+typedef void os_timer_t;
+#endif
+
+#ifndef OS_TICK
+typedef void os_tick_t;
+#endif
+
+void * os_malloc (size_t size);
+void os_free (void * ptr);
+
+void os_usleep (uint32_t us);
+uint32_t os_get_current_time_us (void);
+
+os_tick_t os_tick_current (void);
+os_tick_t os_tick_from_us (uint32_t us);
+void      os_tick_sleep (os_tick_t tick);
+
+os_thread_t * os_thread_create (
+   const char * name,
+   uint32_t priority,
+   size_t stacksize,
+   void (*entry) (void * arg),
+   void * arg);
+
+os_mutex_t * os_mutex_create (void);
+void os_mutex_lock (os_mutex_t * mutex);
+void os_mutex_unlock (os_mutex_t * mutex);
+void os_mutex_destroy (os_mutex_t * mutex);
+
+os_sem_t * os_sem_create (size_t count);
+bool os_sem_wait (os_sem_t * sem, uint32_t time);
+void os_sem_signal (os_sem_t * sem);
+void os_sem_destroy (os_sem_t * sem);
+
+os_event_t * os_event_create (void);
+bool os_event_wait (
+   os_event_t * event,
+   uint32_t mask,
+   uint32_t * value,
+   uint32_t time);
+void os_event_set (os_event_t * event, uint32_t value);
+void os_event_clr (os_event_t * event, uint32_t value);
+void os_event_destroy (os_event_t * event);
+
+os_mbox_t * os_mbox_create (size_t size);
+bool os_mbox_fetch (os_mbox_t * mbox, void ** msg, uint32_t time);
+bool os_mbox_post (os_mbox_t * mbox, void * msg, uint32_t time);
+void os_mbox_destroy (os_mbox_t * mbox);
+
+os_timer_t * os_timer_create (
+   uint32_t us,
+   void (*fn) (os_timer_t * timer, void * arg),
+   void * arg,
+   bool oneshot);
+void os_timer_set (os_timer_t * timer, uint32_t us);
+void os_timer_start (os_timer_t * timer);
+void os_timer_stop (os_timer_t * timer);
+void os_timer_destroy (os_timer_t * timer);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* OSAL_H */
diff --git a/src/ports/nuttx/osal/osal_log.c b/src/ports/nuttx/osal/osal_log.c
new file mode 100644
index 0000000..cc7c587
--- /dev/null
+++ b/src/ports/nuttx/osal/osal_log.c
@@ -0,0 +1,69 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2017 rt-labs AB, Sweden.
+ *
+ * This software is licensed under the terms of the BSD 3-clause
+ * license. See the file LICENSE distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#include "osal_log.h"
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <time.h>
+
+/**
+ * @brief Logs a formatted message with a timestamp and specified log level.
+ *
+ * This function prints a log message with a timestamp and a specified log level.
+ * The log message format is similar to printf, allowing for formatted output.
+ * The log level determines the prefix of the log message (e.g., DEBUG, INFO, WARN, ERROR, FATAL).
+ *
+ * @param type The log level and type, which determines the prefix of the log message.
+ * @param fmt  The format string for the log message, followed by additional arguments.
+ */
+
+void os_log (uint8_t type, const char * fmt, ...)
+{
+   va_list list;
+   time_t rawtime;
+   struct tm timestruct;
+   char timestamp[10];
+
+   time (&rawtime);
+   localtime_r (&rawtime, &timestruct);
+   strftime (timestamp, sizeof (timestamp), "%H:%M:%S", &timestruct);
+
+   switch (LOG_LEVEL_GET (type))
+   {
+   case LOG_LEVEL_DEBUG:
+      printf ("[%s DEBUG] ", timestamp);
+      break;
+   case LOG_LEVEL_INFO:
+      printf ("[%s INFO ] ", timestamp);
+      break;
+   case LOG_LEVEL_WARNING:
+      printf ("[%s WARN ] ", timestamp);
+      break;
+   case LOG_LEVEL_ERROR:
+      printf ("[%s ERROR] ", timestamp);
+      break;
+   case LOG_LEVEL_FATAL:
+      printf ("[%s FATAL] ", timestamp);
+      break;
+   default:
+      break;
+   }
+
+   va_start (list, fmt);
+   vprintf (fmt, list);
+   va_end (list);
+   fflush (stdout);
+}
diff --git a/src/ports/nuttx/osal/osal_log.h b/src/ports/nuttx/osal/osal_log.h
new file mode 100644
index 0000000..55c1c7b
--- /dev/null
+++ b/src/ports/nuttx/osal/osal_log.h
@@ -0,0 +1,78 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2017 rt-labs AB, Sweden.
+ *
+ * This software is licensed under the terms of the BSD 3-clause
+ * license. See the file LICENSE distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#ifndef OSAL_LOG_H
+#define OSAL_LOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "osal.h"
+
+/* Log levels */
+#define LOG_LEVEL_DEBUG   0x00
+#define LOG_LEVEL_INFO    0x01
+#define LOG_LEVEL_WARNING 0x02
+#define LOG_LEVEL_ERROR   0x03
+#define LOG_LEVEL_FATAL   0x04
+#define LOG_LEVEL_MASK    0x07
+#define LOG_LEVEL_GET(t)  (t & LOG_LEVEL_MASK)
+
+/* Log states */
+#define LOG_STATE_ON  0x80
+#define LOG_STATE_OFF 0x00
+
+#define LOG_ENABLED(type)                                                      \
+   ((LOG_LEVEL_GET (type) >= LOG_LEVEL) && (type & LOG_STATE_ON))
+
+/** Log a message if it is enabled */
+#define LOG(type, ...)                                                         \
+   do                                                                          \
+   {                                                                           \
+      if (LOG_ENABLED (type))                                                  \
+      {                                                                        \
+         os_log (type, __VA_ARGS__);                                           \
+      }                                                                        \
+   } while (0)
+
+/** Log debug messages */
+#define LOG_DEBUG(type, ...) LOG ((LOG_LEVEL_DEBUG | type), __VA_ARGS__)
+
+/** Log informational messages */
+#define LOG_INFO(type, ...) LOG ((LOG_LEVEL_INFO | type), __VA_ARGS__)
+
+/** Log warning messages */
+#define LOG_WARNING(type, ...) LOG ((LOG_LEVEL_WARNING | type), __VA_ARGS__)
+
+/** Log error messages */
+#define LOG_ERROR(type, ...) LOG ((LOG_LEVEL_ERROR | type), __VA_ARGS__)
+
+/** Log fatal messages */
+#define LOG_FATAL(type, ...) LOG ((LOG_LEVEL_FATAL | type), __VA_ARGS__)
+
+#define LOG_DEBUG_ENABLED(type)   LOG_ENABLED (LOG_LEVEL_DEBUG | type)
+#define LOG_INFO_ENABLED(type)    LOG_ENABLED (LOG_LEVEL_INFO | type)
+#define LOG_WARNING_ENABLED(type) LOG_ENABLED (LOG_LEVEL_WARNING | type)
+#define LOG_ERROR_ENABLED(type)   LOG_ENABLED (LOG_LEVEL_ERROR | type)
+#define LOG_FATAL_ENABLED(type)   LOG_ENABLED (LOG_LEVEL_FATAL | type)
+
+void os_log (uint8_t type, const char * fmt, ...) CC_FORMAT (2, 3);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* OSAL_LOG_H */
diff --git a/src/ports/nuttx/pnal.c b/src/ports/nuttx/pnal.c
new file mode 100644
index 0000000..19b77bf
--- /dev/null
+++ b/src/ports/nuttx/pnal.c
@@ -0,0 +1,410 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2018 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#define _GNU_SOURCE /* For asprintf() */
+
+#include "pnal.h"
+
+#include "options.h"
+#include "osal.h"
+#include "osal_log.h"
+#include "pnal_filetools.h"
+
+#include <net/if.h>
+#include <arpa/inet.h>
+#include <ifaddrs.h>
+#include <pthread.h>
+
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/syscall.h>
+#include <sys/sysinfo.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+/********************************* Files *************************************/
+
+int pnal_save_file (
+   const char * fullpath,
+   const void * object_1,
+   size_t size_1,
+   const void * object_2,
+   size_t size_2)
+{
+   int ret = 0; /* Assume everything goes well */
+   int outputfile;
+
+   /* Open file
+      Use synchronized write to make sure it ends up on disk immediately */
+   outputfile = open (
+      fullpath,
+      O_WRONLY | O_CREAT | O_TRUNC | O_SYNC,
+      S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+   if (outputfile == -1)
+   {
+      LOG_ERROR (
+         PF_PNAL_LOG,
+         "PNAL(%d): Could not open file %s\n",
+         __LINE__,
+         fullpath);
+      return -1;
+   }
+
+   /* Write file contents */
+   if (size_1 > 0)
+   {
+      if (write (outputfile, object_1, size_1) == -1)
+      {
+         ret = -1;
+         LOG_ERROR (
+            PF_PNAL_LOG,
+            "PNAL(%d): Failed to write file %s\n",
+            __LINE__,
+            fullpath);
+      }
+   }
+   if (size_2 > 0 && ret == 0)
+   {
+      if (write (outputfile, object_2, size_2) == -1)
+      {
+         ret = -1;
+         LOG_ERROR (
+            PF_PNAL_LOG,
+            "PNAL(%d): Failed to write file %s (second buffer)\n",
+            __LINE__,
+            fullpath);
+      }
+   }
+
+   /* Close file */
+   if (close (outputfile) != 0)
+   {
+      ret = -1;
+   }
+
+   return ret;
+}
+
+void pnal_clear_file (const char * fullpath)
+{
+   LOG_DEBUG (PF_PNAL_LOG, "PNAL(%d): Clearing file %s\n", __LINE__, fullpath);
+   (void)remove (fullpath);
+}
+
+int pnal_load_file (
+   const char * fullpath,
+   void * object_1,
+   size_t size_1,
+   void * object_2,
+   size_t size_2)
+{
+   int ret = 0; /* Assume everything goes well */
+   int inputfile;
+
+   /* Open file */
+   inputfile = open (fullpath, O_RDONLY);
+   if (inputfile == -1)
+   {
+      LOG_DEBUG (
+         PF_PNAL_LOG,
+         "PNAL(%d): Could not yet open file %s\n",
+         __LINE__,
+         fullpath);
+      return -1;
+   }
+
+   /* Read file contents */
+   if (size_1 > 0)
+   {
+      if (read (inputfile, object_1, size_1) <= 0)
+      {
+         ret = -1;
+         LOG_ERROR (
+            PF_PNAL_LOG,
+            "PNAL(%d): Failed to read file %s\n",
+            __LINE__,
+            fullpath);
+      }
+   }
+
+   if (size_2 > 0 && ret == 0)
+   {
+      if (read (inputfile, object_2, size_2) <= 0)
+      {
+         ret = -1;
+         LOG_ERROR (
+            PF_PNAL_LOG,
+            "PNAL(%d): Failed to read file %s (second buffer)\n",
+            __LINE__,
+            fullpath);
+      }
+   }
+
+   /* Close file */
+   if (close (inputfile) != 0)
+   {
+      ret = -1;
+   }
+
+   return ret;
+}
+
+/*****************************************************************************/
+
+uint32_t pnal_get_system_uptime_10ms (void)
+{
+   struct sysinfo systeminfo; /* Field .uptime contains uptime in seconds */
+
+   if (sysinfo (&systeminfo) != 0)
+   {
+      return 0;
+   }
+
+   return systeminfo.uptime * 100;
+}
+
+uint32_t pnal_buf_alloc_cnt = 0; /* Count outstanding buffers */
+
+pnal_buf_t * pnal_buf_alloc (uint16_t length)
+{
+   pnal_buf_t * p = malloc (sizeof (pnal_buf_t) + length);
+
+   if (p != NULL)
+   {
+      p->payload = (void *)((uint8_t *)p + sizeof (pnal_buf_t)); /* Payload
+                                                                  follows header
+                                                                  struct */
+      p->len = length;
+      pnal_buf_alloc_cnt++;
+   }
+   else
+   {
+      assert ("malloc() failed\n");
+   }
+
+   return p;
+}
+
+void pnal_buf_free (pnal_buf_t * p)
+{
+   free (p);
+   pnal_buf_alloc_cnt--;
+   return;
+}
+
+uint8_t pnal_buf_header (pnal_buf_t * p, int16_t header_size_increment)
+{
+   return 255;
+}
+
+/************************** Networking ***************************************/
+
+/** @internal
+ * Convert IPv4 address to string
+ * @param ip               In:    IP address
+ * @param outputstring     Out:   Resulting string. Should have size
+ *                                PNAL_INET_ADDRSTR_SIZE.
+ */
+static void os_ip_to_string (pnal_ipaddr_t ip, char * outputstring)
+{
+   snprintf (
+      outputstring,
+      PNAL_INET_ADDRSTR_SIZE,
+      "%u.%u.%u.%u",
+      (uint8_t)((ip >> 24) & 0xFF),
+      (uint8_t)((ip >> 16) & 0xFF),
+      (uint8_t)((ip >> 8) & 0xFF),
+      (uint8_t)(ip & 0xFF));
+}
+
+int pnal_set_ip_suite (
+   const char * interface_name,
+   const pnal_ipaddr_t * p_ipaddr,
+   const pnal_ipaddr_t * p_netmask,
+   const pnal_ipaddr_t * p_gw,
+   const char * hostname,
+   bool permanent)
+{
+   char ip_string[PNAL_INET_ADDRSTR_SIZE];      /** Terminated string */
+   char netmask_string[PNAL_INET_ADDRSTR_SIZE]; /** Terminated string */
+   char gateway_string[PNAL_INET_ADDRSTR_SIZE]; /** Terminated string */
+   const char * argv[8];
+
+   os_ip_to_string (*p_ipaddr, ip_string);
+   os_ip_to_string (*p_netmask, netmask_string);
+   os_ip_to_string (*p_gw, gateway_string);
+
+   argv[0] = "set_network_parameters";
+   argv[1] = interface_name;
+   argv[2] = (char *)&ip_string;
+   argv[3] = (char *)&netmask_string;
+   argv[4] = (char *)&gateway_string;
+   argv[5] = hostname;
+   argv[6] = permanent ? "1" : "0";
+   argv[7] = NULL;
+
+   return pnal_execute_script (argv);
+}
+
+int pnal_eth_get_status (const char * interface_name, pnal_eth_status_t * status)
+{
+   status->is_autonegotiation_supported = false;
+   status->is_autonegotiation_enabled = false;
+   status->autonegotiation_advertised_capabilities = 0;
+
+   status->operational_mau_type = PNAL_ETH_MAU_COPPER_100BaseTX_FULL_DUPLEX;
+   status->running = true;
+
+   return 0;
+}
+
+int pnal_get_interface_index (const char * interface_name)
+{
+   return if_nametoindex (interface_name);
+}
+
+int pnal_get_port_statistics (
+   const char * interface_name,
+   pnal_port_stats_t * port_stats)
+{
+   port_stats->if_in_octets = 0;
+   port_stats->if_in_errors = 0;
+   port_stats->if_in_discards = 0;
+   port_stats->if_out_octets = 0;
+   port_stats->if_out_errors = 0;
+   port_stats->if_out_discards = 0;
+
+   return 0;
+}
+
+int pnal_get_macaddress (const char * interface_name, pnal_ethaddr_t * mac_addr)
+{
+   int fd;
+   int ret = 0;
+   struct ifreq ifr;
+
+   fd = socket (AF_INET, SOCK_DGRAM, 0);
+
+   ifr.ifr_addr.sa_family = AF_INET;
+   strncpy (ifr.ifr_name, interface_name, IFNAMSIZ - 1);
+
+   ret = ioctl (fd, SIOCGIFHWADDR, &ifr);
+   if (ret == 0)
+   {
+      memcpy (mac_addr->addr, ifr.ifr_hwaddr.sa_data, 6);
+   }
+   close (fd);
+   return ret;
+}
+
+pnal_ipaddr_t pnal_get_ip_address (const char * interface_name)
+{
+   int fd;
+   struct ifreq ifr;
+   pnal_ipaddr_t ip;
+
+   fd = socket (AF_INET, SOCK_DGRAM, 0);
+   ifr.ifr_addr.sa_family = AF_INET;
+   strncpy (ifr.ifr_name, interface_name, IFNAMSIZ - 1);
+
+   if (ioctl (fd, SIOCGIFADDR, &ifr) != 0)
+   {
+      close (fd);
+      return PNAL_IPADDR_INVALID;
+   }
+
+   ip = ntohl (((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr);
+   close (fd);
+
+   return ip;
+}
+
+pnal_ipaddr_t pnal_get_netmask (const char * interface_name)
+{
+   int fd;
+   struct ifreq ifr;
+   pnal_ipaddr_t netmask;
+
+   fd = socket (AF_INET, SOCK_DGRAM, 0);
+
+   ifr.ifr_addr.sa_family = AF_INET;
+   strncpy (ifr.ifr_name, interface_name, IFNAMSIZ - 1);
+
+   if (ioctl (fd, SIOCGIFNETMASK, &ifr) != 0)
+   {
+      close (fd);
+      return PNAL_IPADDR_INVALID;
+   }
+
+   netmask = ntohl (((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr);
+   close (fd);
+
+   return netmask;
+}
+
+pnal_ipaddr_t pnal_get_gateway (const char * interface_name)
+{
+   /* TODO Read the actual default gateway (somewhat complicated) */
+
+   pnal_ipaddr_t ip;
+   pnal_ipaddr_t gateway;
+
+   ip = pnal_get_ip_address (interface_name);
+   if (ip == PNAL_IPADDR_INVALID)
+   {
+      return PNAL_IPADDR_INVALID;
+   }
+
+   gateway = (ip & 0xFFFFFF00) | 0x00000001;
+
+   return gateway;
+}
+
+int pnal_get_hostname (char * hostname)
+{
+   int ret = -1;
+
+   ret = gethostname (hostname, PNAL_HOSTNAME_MAX_SIZE);
+   hostname[PNAL_HOSTNAME_MAX_SIZE - 1] = '\0';
+
+   return ret;
+}
+
+int pnal_get_ip_suite (
+   const char * interface_name,
+   pnal_ipaddr_t * p_ipaddr,
+   pnal_ipaddr_t * p_netmask,
+   pnal_ipaddr_t * p_gw,
+   char * hostname)
+{
+   int ret = -1;
+
+   *p_ipaddr = pnal_get_ip_address (interface_name);
+   *p_netmask = pnal_get_netmask (interface_name);
+   *p_gw = pnal_get_gateway (interface_name);
+   ret = pnal_get_hostname (hostname);
+
+   return ret;
+}
diff --git a/src/ports/nuttx/pnal_config.h b/src/ports/nuttx/pnal_config.h
new file mode 100644
index 0000000..6b1be0b
--- /dev/null
+++ b/src/ports/nuttx/pnal_config.h
@@ -0,0 +1,54 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2021 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/**
+ * @file
+ * @brief PNAL-specific configuration
+ *
+ * This file contains definitions of configuration settings for the
+ * PNAL layer.
+ */
+
+#ifndef PNAL_CONFIG_H
+#define PNAL_CONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <stddef.h>
+
+/**
+ * Thread priority and stack size
+ */
+typedef struct pnal_thread_cfg
+{
+   uint32_t prio;
+   size_t stack_size;
+} pnal_thread_cfg_t;
+
+typedef struct pnal_cfg
+{
+   pnal_thread_cfg_t snmp_thread;
+   pnal_thread_cfg_t eth_recv_thread;
+   pnal_thread_cfg_t bg_worker_thread;
+} pnal_cfg_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PNAL_CONFIG_H */
diff --git a/src/ports/nuttx/pnal_eth.c b/src/ports/nuttx/pnal_eth.c
new file mode 100644
index 0000000..1142216
--- /dev/null
+++ b/src/ports/nuttx/pnal_eth.c
@@ -0,0 +1,188 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2018 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+/**
+ * @file
+ * @brief Linux Ethernet related functions that use \a pnal_eth_handle_t
+ */
+
+#include "pnal.h"
+
+#include "pnet_options.h"
+#include "options.h"
+#include "osal_log.h"
+
+#include <netpacket/packet.h>
+#include <net/ethernet.h>
+#include <net/if.h>
+
+#include <sys/ioctl.h>
+#include <sys/time.h>
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "netutils/netlib.h"
+#include "netutils/ipmsfilter.h"
+
+struct pnal_eth_handle
+{
+   pnal_eth_callback_t * callback;
+   void * arg;
+   int socket;
+   os_thread_t * thread;
+};
+
+/**
+ * @internal
+ * Run a thread that listens to incoming raw Ethernet sockets.
+ * Delegate the actual work to thread_arg->callback
+ *
+ * This is a function to be passed into os_thread_create()
+ * Do not change the argument types.
+ *
+ * @param thread_arg     InOut: Will be converted to pnal_eth_handle_t
+ */
+static void os_eth_task (void * thread_arg)
+{
+   pnal_eth_handle_t * eth_handle = thread_arg;
+   ssize_t readlen;
+   int handled = 0;
+
+   pnal_buf_t * p = pnal_buf_alloc (PNAL_BUF_MAX_SIZE);
+   assert (p != NULL);
+
+   while (1)
+   {
+      readlen = recv (eth_handle->socket, p->payload, PNAL_BUF_MAX_SIZE, 0);
+      if (readlen == -1)
+         continue;
+      p->len = readlen;
+
+      if (eth_handle->callback != NULL)
+      {
+         handled = eth_handle->callback (eth_handle, eth_handle->arg, p);
+      }
+      else
+      {
+         handled = 0; /* Message not handled */
+      }
+
+      if (handled == 1)
+      {
+         p = pnal_buf_alloc (PNAL_BUF_MAX_SIZE);
+         assert (p != NULL);
+      }
+   }
+}
+
+pnal_eth_handle_t * pnal_eth_init (
+   const char * if_name,
+   pnal_ethertype_t receive_type,
+   const pnal_cfg_t * pnal_cfg,
+   pnal_eth_callback_t * callback,
+   void * arg)
+{
+   pnal_eth_handle_t * handle;
+   int i;
+   struct ifreq ifr;
+   struct sockaddr_ll sll;
+   int ifindex;
+   struct timeval timeout;
+   struct in_addr mcast;
+   struct in_addr iaddr;
+
+   handle = malloc (sizeof (pnal_eth_handle_t));
+   if (handle == NULL)
+   {
+      return NULL;
+   }
+
+   handle->arg = arg;
+   handle->callback = callback;
+   handle->socket = socket (PF_PACKET, SOCK_RAW, htons(receive_type));
+
+   /* Adjust send timeout */
+   timeout.tv_sec = 0;
+   timeout.tv_usec = 1;
+   setsockopt (
+      handle->socket,
+      SOL_SOCKET,
+      SO_SNDTIMEO,
+      &timeout,
+      sizeof (timeout));
+
+   /* Send outgoing messages directly to the interface, without using Linux
+    * routing */
+   i = 1;
+   setsockopt (handle->socket, SOL_SOCKET, SO_DONTROUTE, &i, sizeof (i));
+
+   /* Read interface index */
+   strcpy (ifr.ifr_name, if_name);
+   ioctl (handle->socket, SIOCGIFINDEX, &ifr);
+   ifindex = ifr.ifr_ifindex;
+
+   /* Set flags of NIC interface */
+   strcpy (ifr.ifr_name, if_name);
+   ifr.ifr_flags = 0;
+   ioctl (handle->socket, SIOCGIFFLAGS, &ifr);
+   ifr.ifr_flags = ifr.ifr_flags | IFF_MULTICAST | IFF_BROADCAST;
+   if (receive_type == PNAL_ETHTYPE_ALL)
+   {
+      ifr.ifr_flags |= IFF_MULTICAST; /* Receive all multicasts */
+   }
+   ioctl (handle->socket, SIOCSIFFLAGS, &ifr);
+
+   /* Bind socket to relevant protocol */
+   sll.sll_family = AF_PACKET;
+   sll.sll_ifindex = ifindex;
+   sll.sll_protocol = htons (receive_type);
+   bind (handle->socket, (struct sockaddr *)&sll, sizeof (sll));
+
+   /* Join profinet multicast group */
+
+   mcast.s_addr = HTONL(0x0a000001);
+	 iaddr.s_addr = ((FAR struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr;
+
+   if (ipmsfilter(&iaddr, &mcast, MCAST_INCLUDE) != 0)
+   {
+      LOG_WARNING (
+         PF_PNAL_LOG,
+         "PNAL(%d): Failed to join Profinet multicast group\n",
+         __LINE__);
+   }
+
+   if (handle->socket > -1)
+   {
+      handle->thread = os_thread_create (
+         "os_eth_task",
+         pnal_cfg->eth_recv_thread.prio,
+         pnal_cfg->eth_recv_thread.stack_size,
+         os_eth_task,
+         handle);
+      return handle;
+   }
+   else
+   {
+      free (handle);
+      return NULL;
+   }
+}
+
+int pnal_eth_send (pnal_eth_handle_t * handle, pnal_buf_t * buf)
+{
+   int ret = send (handle->socket, buf->payload, buf->len, 0);
+   return ret;
+}
diff --git a/src/ports/nuttx/pnal_filetools.c b/src/ports/nuttx/pnal_filetools.c
new file mode 100644
index 0000000..f19e995
--- /dev/null
+++ b/src/ports/nuttx/pnal_filetools.c
@@ -0,0 +1,225 @@
+
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#define _GNU_SOURCE /* Enable execvpe () */
+
+#include "pnal_filetools.h"
+
+#include "pnet_options.h"
+#include "options.h"
+#include "osal_log.h"
+
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+bool pnal_does_file_exist (const char * filepath)
+{
+   struct stat statbuffer;
+
+   return (stat (filepath, &statbuffer) == 0);
+}
+
+/**
+ * @internal
+ * Get the path to the directory where the main binary is located.
+ *
+ * @param tempstring       Temp:  Temporary buffer.
+ * @param dirpath          Out:   Path to directory. Terminated string.
+ * @param size             In:    Size of the stringbuffers. Should be large
+ *                                enough for the full path to the binary.
+ *
+ * @return 0 on success.
+ *         -1 if an error occurred.
+ */
+static int pnal_get_directory_of_binary (
+   char * tempstring,
+   char * dirpath,
+   size_t size)
+{
+   ssize_t num_bytes = 0;
+   memset (tempstring, 0, size); /* Path to executable */
+   memset (dirpath, 0, size);
+   char * resulting_directory = NULL;
+
+   num_bytes = readlink ("/proc/self/exe", tempstring, size);
+   if (num_bytes == -1)
+   {
+      return -1;
+   }
+
+   /* Verify that we have the full path (size is big enough) */
+   if (!pnal_does_file_exist (tempstring))
+   {
+      return -1;
+   }
+
+   resulting_directory = dirname (tempstring);
+   snprintf (dirpath, size, "%s", resulting_directory);
+
+   return 0;
+}
+
+/**
+ * @internal
+ * Create a PATH string used when searching for scripts
+ *
+ * The PATH string is colon separated, and includes the directory where
+ * the main binary is located.
+ *
+ * @param path             Out:   Resulting path. Terminated string.
+ *                                Might be modified also on failure.
+ * @param size             In:    Size of the outputbuffer. Should be
+ *                                sizeof(PNAL_DEFAULT_SEARCHPATH) +
+ *                                PNET_MAX_DIRECTORYPATH_SIZE
+ * @return 0 on success.
+ *         -1 if an error occurred.
+ */
+int pnal_create_searchpath (char * path, size_t size)
+{
+   int written = 0;
+
+   /** Should temporarily hold full path. Resulting size is
+    * PNET_MAX_DIRECTORYPATH_SIZE */
+   char
+      directory_of_binary[PNET_MAX_DIRECTORYPATH_SIZE + PNET_MAX_FILENAME_SIZE] =
+         {0};
+   char tempstring[PNET_MAX_DIRECTORYPATH_SIZE + PNET_MAX_FILENAME_SIZE] = {0};
+
+   if (
+      pnal_get_directory_of_binary (
+         tempstring,
+         directory_of_binary,
+         sizeof (directory_of_binary)) != 0)
+   {
+      return -1;
+   }
+
+   written = snprintf (
+      path,
+      size,
+      "%s:%s",
+      PNAL_DEFAULT_SEARCHPATH,
+      directory_of_binary);
+   if (written < 0 || (unsigned)written >= size)
+   {
+      return -1;
+   }
+
+   return 0;
+}
+
+int pnal_execute_script (const char * argv[])
+{
+   /** Terminated string, see pnal_create_searchpath() */
+   char child_searchpath
+      [sizeof (PNAL_DEFAULT_SEARCHPATH) + PNET_MAX_DIRECTORYPATH_SIZE] = {0};
+   int childstatus = 0;
+   pid_t childpid;
+   char * scriptenviron[] = {NULL};
+   int script_returnvalue = 0;
+#if LOG_DEBUG_ENABLED(PF_PNAL_LOG)
+   uint16_t ix;
+#endif
+
+   if (argv == NULL)
+   {
+      LOG_ERROR (
+         PF_PNAL_LOG,
+         "PNAL(%d): No argument vector given for running script.\n",
+         __LINE__);
+      return -1;
+   }
+
+   if (argv[0] == NULL)
+   {
+      LOG_ERROR (PF_PNAL_LOG, "PNAL(%d): No script name given.\n", __LINE__);
+      return -1;
+   }
+
+   if (pnal_create_searchpath (child_searchpath, sizeof (child_searchpath)) != 0)
+   {
+      LOG_ERROR (
+         PF_PNAL_LOG,
+         "PNAL(%d): Could not build PATH to run script.\n",
+         __LINE__);
+      return -1;
+   }
+
+#if LOG_DEBUG_ENABLED(PF_PNAL_LOG)
+   printf ("PNAL(%d): Command for script:", __LINE__);
+   for (ix = 0; argv[ix] != NULL; ix++)
+   {
+      if (strlen (argv[ix]) > 0)
+      {
+         printf (" %s", argv[ix]);
+      }
+      else
+      {
+         printf (" ''");
+      }
+   }
+   printf ("\n");
+#endif
+
+   /* Fork and exec */
+   childpid = fork();
+   if (childpid < 0)
+   {
+      LOG_ERROR (
+         PF_PNAL_LOG,
+         "PNAL(%d): Failed to fork the process to run script.\n",
+         __LINE__);
+      return -1;
+   }
+   else if (childpid == 0)
+   {
+      /* We are in the child process */
+
+      /* setenv() will malloc memory. We will not free() it, but it does not
+         matter since we do it in the short-lived child process */
+      if (setenv ("PATH", child_searchpath, 1) != 0)
+      {
+         printf (
+            "PNAL(%d): Failed to set PATH in child process to run script.\n",
+            __LINE__);
+         exit (EXIT_FAILURE);
+      }
+
+      execvpe (argv[0], (char * const *)argv, scriptenviron);
+
+      printf (
+         "PNAL(%d): Failed to execute in child process. Is the script file "
+         "missing or lacks execution permission? %s Search path %s\n",
+         __LINE__,
+         argv[0],
+         child_searchpath);
+      exit (EXIT_FAILURE);
+   }
+   else
+   {
+      /* We are in the parent (original) process */
+      wait (&childstatus);
+      script_returnvalue = WEXITSTATUS (childstatus);
+   }
+
+   return (script_returnvalue == 0) ? 0 : -1;
+}
diff --git a/src/ports/nuttx/pnal_filetools.h b/src/ports/nuttx/pnal_filetools.h
new file mode 100644
index 0000000..4f30e02
--- /dev/null
+++ b/src/ports/nuttx/pnal_filetools.h
@@ -0,0 +1,57 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#ifndef PNAL_FILETOOLS_H
+#define PNAL_FILETOOLS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdbool.h>
+
+/* Colon separated paths to search for scripts. No colon at end. */
+#define PNAL_DEFAULT_SEARCHPATH "/etc"
+
+/**
+ * Check if a file or directory exists
+ *
+ * @param filepath         In:    Path to file or directory. Null terminated.
+ *                                Trailing slash is optional for directories.
+ * @return true if file exists
+ */
+bool pnal_does_file_exist (const char * filepath);
+
+/**
+ * Execute a script.
+ *
+ * The script will be searched for in:
+ * - Directories given in PNAL_DEFAULT_SEARCHPATH
+ * - Same directory as the main binary is located in.
+ *
+ * @param argv             In:    Arguments (null terminated strings).
+ *                                The first argument should be the name of
+ *                                the script.
+ *                                The last element should be NULL.
+ * @return 0 on success
+ *         -1 if an error occurred
+ */
+int pnal_execute_script (const char * argv[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PNAL_FILETOOLS_H */
diff --git a/src/ports/nuttx/pnal_snmp.c b/src/ports/nuttx/pnal_snmp.c
new file mode 100644
index 0000000..04d2311
--- /dev/null
+++ b/src/ports/nuttx/pnal_snmp.c
@@ -0,0 +1,81 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2020 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#include "pnal.h"
+#include "osal.h"
+#include "options.h"
+#include "osal_log.h"
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#include "mib/lldpConfigManAddrTable.h"
+#include "mib/lldpLocalSystemData.h"
+#include "mib/lldpLocManAddrTable.h"
+#include "mib/lldpLocPortTable.h"
+#include "mib/lldpRemManAddrTable.h"
+#include "mib/lldpRemTable.h"
+#include "mib/lldpXdot3LocPortTable.h"
+#include "mib/lldpXdot3RemPortTable.h"
+#include "mib/lldpXPnoLocTable.h"
+#include "mib/lldpXPnoRemTable.h"
+#include "mib/system_mib.h"
+
+static void pnal_snmp_thread (void * arg)
+{
+   struct pnet * pnet = arg;
+
+   snmp_disable_log();
+
+   /* make us an agentx client. */
+   netsnmp_enable_subagent();
+
+   /* initialize the agent library */
+   init_agent ("lldpMIB");
+
+   /* init mib code */
+   init_system_mib (pnet);
+   init_lldpLocalSystemData (pnet);
+   init_lldpLocPortTable (pnet);
+   init_lldpConfigManAddrTable (pnet);
+   init_lldpLocManAddrTable (pnet);
+   init_lldpRemManAddrTable (pnet);
+   init_lldpRemTable (pnet);
+   init_lldpXdot3LocPortTable (pnet);
+   init_lldpXdot3RemPortTable (pnet);
+   init_lldpXPnoLocTable (pnet);
+   init_lldpXPnoRemTable (pnet);
+
+   /* read lldpMIB.conf files. */
+   init_snmp ("lldpMIB");
+
+   for (;;)
+   {
+      agent_check_and_process (1); /* 0 == don't block */
+   }
+}
+
+int pnal_snmp_init (struct pnet * pnet, const pnal_cfg_t * pnal_cfg)
+{
+   os_thread_create (
+      "pn_snmp",
+      pnal_cfg->snmp_thread.prio,
+      pnal_cfg->snmp_thread.stack_size,
+      pnal_snmp_thread,
+      pnet);
+   return 0;
+}
diff --git a/src/ports/nuttx/pnal_sys.h b/src/ports/nuttx/pnal_sys.h
new file mode 100644
index 0000000..e38d1a5
--- /dev/null
+++ b/src/ports/nuttx/pnal_sys.h
@@ -0,0 +1,39 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2018 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#ifndef PNAL_SYS_H
+#define PNAL_SYS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "osal.h"
+
+#include <netinet/in.h>
+
+#define PNAL_BUF_MAX_SIZE 1522
+
+typedef struct os_buf
+{
+   void * payload;
+   uint16_t len;
+} pnal_buf_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PNAL_SYS_H */
diff --git a/src/ports/nuttx/pnal_udp.c b/src/ports/nuttx/pnal_udp.c
new file mode 100644
index 0000000..5e44e0b
--- /dev/null
+++ b/src/ports/nuttx/pnal_udp.c
@@ -0,0 +1,112 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2018 rt-labs AB, Sweden.
+ *
+ * This software is dual-licensed under GPLv3 and a commercial
+ * license. See the file LICENSE.md distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#include "pnal.h"
+#include "pf_includes.h"
+
+#include <string.h>
+#include <unistd.h>
+
+int pnal_udp_open (pnal_ipaddr_t addr, pnal_ipport_t port)
+{
+   struct sockaddr_in local;
+   int id;
+   const int enable = 1;
+
+   id = socket (PF_INET, SOCK_DGRAM, IPPROTO_UDP);
+   if (id == -1)
+   {
+      return -1;
+   }
+
+   if (setsockopt(id, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) != 0)
+   {
+      goto error;
+   }
+
+   /* set IP and port number */
+   local = (struct sockaddr_in){
+      .sin_family = AF_INET,
+      .sin_addr.s_addr = htonl (addr),
+      .sin_port = htons (port),
+      .sin_zero = {0},
+   };
+
+   if (bind (id, (struct sockaddr *)&local, sizeof (local)) != 0)
+   {
+      goto error;
+   }
+
+   return id;
+
+error:
+   close (id);
+   return -1;
+}
+
+int pnal_udp_sendto (
+   uint32_t id,
+   pnal_ipaddr_t dst_addr,
+   pnal_ipport_t dst_port,
+   const uint8_t * data,
+   int size)
+{
+   struct sockaddr_in remote;
+   int len;
+
+   remote = (struct sockaddr_in){
+      .sin_family = AF_INET,
+      .sin_addr.s_addr = htonl (dst_addr),
+      .sin_port = htons (dst_port),
+      .sin_zero = {0},
+   };
+   len =
+      sendto (id, data, size, 0, (struct sockaddr *)&remote, sizeof (remote));
+
+   return len;
+}
+
+int pnal_udp_recvfrom (
+   uint32_t id,
+   pnal_ipaddr_t * src_addr,
+   pnal_ipport_t * src_port,
+   uint8_t * data,
+   int size)
+{
+   struct sockaddr_in remote;
+   socklen_t addr_len = sizeof (remote);
+   int len;
+
+   memset (&remote, 0, sizeof (remote));
+   len = recvfrom (
+      id,
+      data,
+      size,
+      MSG_DONTWAIT,
+      (struct sockaddr *)&remote,
+      &addr_len);
+   if (len > 0)
+   {
+      *src_addr = ntohl (remote.sin_addr.s_addr);
+      *src_port = ntohs (remote.sin_port);
+   }
+
+   return len;
+}
+
+void pnal_udp_close (uint32_t id)
+{
+   close (id);
+}
diff --git a/src/ports/nuttx/pnet_export.h b/src/ports/nuttx/pnet_export.h
new file mode 100644
index 0000000..a44d601
--- /dev/null
+++ b/src/ports/nuttx/pnet_export.h
@@ -0,0 +1,42 @@
+
+#ifndef PNET_EXPORT_H
+#define PNET_EXPORT_H
+
+#ifdef PNET_STATIC_DEFINE
+#  define PNET_EXPORT
+#  define PNET_NO_EXPORT
+#else
+#  ifndef PNET_EXPORT
+#    ifdef profinet_EXPORTS
+        /* We are building this library */
+#      define PNET_EXPORT
+#    else
+        /* We are using this library */
+#      define PNET_EXPORT
+#    endif
+#  endif
+
+#  ifndef PNET_NO_EXPORT
+#    define PNET_NO_EXPORT
+#  endif
+#endif
+
+#ifndef PNET_DEPRECATED
+#  define PNET_DEPRECATED __attribute__ ((__deprecated__))
+#endif
+
+#ifndef PNET_DEPRECATED_EXPORT
+#  define PNET_DEPRECATED_EXPORT PNET_EXPORT PNET_DEPRECATED
+#endif
+
+#ifndef PNET_DEPRECATED_NO_EXPORT
+#  define PNET_DEPRECATED_NO_EXPORT PNET_NO_EXPORT PNET_DEPRECATED
+#endif
+
+#if 0 /* DEFINE_NO_DEPRECATED */
+#  ifndef PNET_NO_DEPRECATED
+#    define PNET_NO_DEPRECATED
+#  endif
+#endif
+
+#endif /* PNET_EXPORT_H */
diff --git a/src/ports/nuttx/sys/osal_cc.h b/src/ports/nuttx/sys/osal_cc.h
new file mode 100644
index 0000000..540ac4e
--- /dev/null
+++ b/src/ports/nuttx/sys/osal_cc.h
@@ -0,0 +1,101 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2017 rt-labs AB, Sweden.
+ *
+ * This software is licensed under the terms of the BSD 3-clause
+ * license. See the file LICENSE distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#ifndef CC_H
+#define CC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <assert.h>
+#include <endian.h>
+
+#if defined(__clang__)
+#if !defined(CLANG_ANALYZER_NORETURN)
+#if __has_feature(attribute_analyzer_noreturn)
+#define CLANG_ANALYZER_NORETURN __attribute__ ((analyzer_noreturn))
+#else
+#define CLANG_ANALYZER_NORETURN
+#endif
+#endif
+#else
+#define CLANG_ANALYZER_NORETURN
+#endif
+
+static inline void cc_assert (int exp) CLANG_ANALYZER_NORETURN
+{
+   assert (exp); // LCOV_EXCL_LINE
+}
+
+#define CC_PACKED_BEGIN
+#define CC_PACKED_END
+#define CC_PACKED __attribute__ ((packed))
+
+#define CC_FORMAT(str, arg) __attribute__ ((format (printf, str, arg)))
+
+#if BYTE_ORDER == LITTLE_ENDIAN
+#define CC_TO_LE16(x)   ((uint16_t)(x))
+#define CC_TO_LE32(x)   ((uint32_t)(x))
+#define CC_TO_LE64(x)   ((uint64_t)(x))
+#define CC_FROM_LE16(x) ((uint16_t)(x))
+#define CC_FROM_LE32(x) ((uint32_t)(x))
+#define CC_FROM_LE64(x) ((uint64_t)(x))
+#define CC_TO_BE16(x)   ((uint16_t)__builtin_bswap16 (x))
+#define CC_TO_BE32(x)   ((uint32_t)__builtin_bswap32 (x))
+#define CC_TO_BE64(x)   ((uint64_t)__builtin_bswap64 (x))
+#define CC_FROM_BE16(x) ((uint16_t)__builtin_bswap16 (x))
+#define CC_FROM_BE32(x) ((uint32_t)__builtin_bswap32 (x))
+#define CC_FROM_BE64(x) ((uint64_t)__builtin_bswap64 (x))
+#else
+#define CC_TO_LE16(x)   ((uint16_t)__builtin_bswap16 (x))
+#define CC_TO_LE32(x)   ((uint32_t)__builtin_bswap32 (x))
+#define CC_TO_LE64(x)   ((uint64_t)__builtin_bswap64 (x))
+#define CC_FROM_LE16(x) ((uint16_t)__builtin_bswap16 (x))
+#define CC_FROM_LE32(x) ((uint32_t)__builtin_bswap32 (x))
+#define CC_FROM_LE64(x) ((uint64_t)__builtin_bswap64 (x))
+#define CC_TO_BE16(x)   ((uint16_t)(x))
+#define CC_TO_BE32(x)   ((uint32_t)(x))
+#define CC_TO_BE64(x)   ((uint64_t)(x))
+#define CC_FROM_BE16(x) ((uint16_t)(x))
+#define CC_FROM_BE32(x) ((uint32_t)(x))
+#define CC_FROM_BE64(x) ((uint64_t)(x))
+#endif
+
+#define CC_ATOMIC_GET8(p)  __atomic_load_n ((p), __ATOMIC_SEQ_CST)
+#define CC_ATOMIC_GET16(p) __atomic_load_n ((p), __ATOMIC_SEQ_CST)
+#define CC_ATOMIC_GET32(p) __atomic_load_n ((p), __ATOMIC_SEQ_CST)
+#define CC_ATOMIC_GET64(p) __atomic_load_n ((p), __ATOMIC_SEQ_CST)
+
+#define CC_ATOMIC_SET8(p, v)  __atomic_store_n ((p), (v), __ATOMIC_SEQ_CST)
+#define CC_ATOMIC_SET16(p, v) __atomic_store_n ((p), (v), __ATOMIC_SEQ_CST)
+#define CC_ATOMIC_SET32(p, v) __atomic_store_n ((p), (v), __ATOMIC_SEQ_CST)
+#define CC_ATOMIC_SET64(p, v) __atomic_store_n ((p), (v), __ATOMIC_SEQ_CST)
+
+#define CC_ASSERT(exp) cc_assert (exp)
+
+#ifdef __cplusplus
+#define CC_STATIC_ASSERT(exp) static_assert (exp, "")
+#else
+#define CC_STATIC_ASSERT(exp) _Static_assert(exp, "")
+#endif
+
+#define CC_UNUSED(var) (void)(var)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CC_H */
diff --git a/src/ports/nuttx/sys/osal_sys.h b/src/ports/nuttx/sys/osal_sys.h
new file mode 100644
index 0000000..870fad6
--- /dev/null
+++ b/src/ports/nuttx/sys/osal_sys.h
@@ -0,0 +1,80 @@
+/*********************************************************************
+ *        _       _         _
+ *  _ __ | |_  _ | |  __ _ | |__   ___
+ * | '__|| __|(_)| | / _` || '_ \ / __|
+ * | |   | |_  _ | || (_| || |_) |\__ \
+ * |_|    \__|(_)|_| \__,_||_.__/ |___/
+ *
+ * www.rt-labs.com
+ * Copyright 2017 rt-labs AB, Sweden.
+ *
+ * This software is licensed under the terms of the BSD 3-clause
+ * license. See the file LICENSE distributed with this software for
+ * full license information.
+ ********************************************************************/
+
+#ifndef OSAL_SYS_H
+#define OSAL_SYS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <pthread.h>
+#include <time.h>
+
+#define OS_THREAD
+#define OS_MUTEX
+#define OS_SEM
+#define OS_EVENT
+#define OS_MBOX
+#define OS_TIMER
+#define OS_TICK
+
+typedef pthread_t os_thread_t;
+typedef pthread_mutex_t os_mutex_t;
+
+typedef struct os_sem
+{
+   pthread_cond_t cond;
+   pthread_mutex_t mutex;
+   size_t count;
+} os_sem_t;
+
+typedef struct os_event
+{
+   pthread_cond_t cond;
+   pthread_mutex_t mutex;
+   uint32_t flags;
+} os_event_t;
+
+typedef struct os_mbox
+{
+   pthread_cond_t cond;
+   pthread_mutex_t mutex;
+   size_t r;
+   size_t w;
+   size_t count;
+   size_t size;
+   void * msg[];
+} os_mbox_t;
+
+typedef struct os_timer
+{
+   timer_t timerid;
+   os_thread_t * thread;
+   pid_t thread_id;
+   bool exit;
+   void (*fn) (struct os_timer *, void * arg);
+   void * arg;
+   uint32_t us;
+   bool oneshot;
+} os_timer_t;
+
+typedef uint64_t os_tick_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* OSAL_SYS_H */
